{"video": {"id": "tWVWeAqZ0WU", "title": "Graph Algorithms for Technical Interviews - Full Course", "description": "Learn how to implement graph algorithms and how to use them to solve coding challenges.\n\n\u270f\ufe0f This course was developed by Alvin Zablan from Structy. Check out Alvin's channel: https://www.youtube.com/c/AlvinTheProgrammer\n\n\ud83d\udd17 Learn data structures and algorithms: https://structy.net/\n\n\u2b50\ufe0f Course Contents \u2b50\ufe0f\n\u2328\ufe0f (0:00:00) course introduction\n\u2328\ufe0f (0:02:23) graph basics\n\u2328\ufe0f (0:07:10) depth first and breadth first traversal\n\u2328\ufe0f (0:29:13) has path - https://structy.net/problems/has-path\n\u2328\ufe0f (0:42:11) undirected path - https://structy.net/problems/undirected-path\n\u2328\ufe0f (1:00:44) connected components count - https://structy.net/problems/connected-components-count\n\u2328\ufe0f (1:13:29) largest component - https://structy.net/problems/largest-component\n\u2328\ufe0f (1:24:03) shortest path - https://structy.net/problems/shortest-path\n\u2328\ufe0f (1:39:36) island count - https://structy.net/problems/island-count\n\u2328\ufe0f (1:58:52) minimum island - https://structy.net/problems/minimum-island\n\u2328\ufe0f (2:12:05) outro\n\n\ud83c\udf89 Thanks to our Champion and Sponsor supporters:\n\ud83d\udc7e Wong Voon jinq\n\ud83d\udc7e hexploitation\n\ud83d\udc7e Katia Moran\n\ud83d\udc7e BlckPhantom\n\ud83d\udc7e Nick Raker\n\ud83d\udc7e Otis Morgan\n\ud83d\udc7e DeezMaster\n\ud83d\udc7e Treehouse\n\ud83d\udc7e AppWrite\n\n--\n\nLearn to code for free and get a developer job: https://www.freecodecamp.org\n\nRead hundreds of articles on programming: https://freecodecamp.org/news", "duration": "PT2H12M19S", "likes": "21332", "views": "851157"}, "comments": [{"topLevelComment": {"author": "Alvin the Programmer", "text": "Hey Programmers! Thanks for checking out the course and I hope you find it useful as you prepare for those tech interviews. If you enjoyed this content, be sure to check out Structy for more data structure and algorithm tutorials from me. Links in the description!\n\nThere I cover all of the common interview topics and you can code along and run test cases directly on the platform. You'll also be able to find video walkthroughs for every problem in JavaScript and Python, (more language support coming soon!).\n\nCheers!\n-Alvin", "likes": 490}, "replies": [{"author": "ewwitsantonio", "text": "Alvin, you are a SUPER skilled teacher. The way you explain your code as you write is very clear and thoughtful of the learner. Much appreciated.", "likes": 0}, {"author": "Sushmita Goswami", "text": "I wish all your courses were free. You are the BEST.", "likes": 0}, {"author": "Rus Cul", "text": "just subscribed! thank you so much for this guys!!! big help for people like me who cant afford subscription fees", "likes": 0}, {"author": "osagie osemwota", "text": "hello please i need help...on the Largest Component question, i decided to not use the recursive method in my DFS function but i am stuck in a bug... Every single one of the test cases on structy works except the first...here is my code  : \n\n// Write a function, largestComponent, that takes in the adjacency list of an undirected graph. The function should return the size of the largest connected component in the graph.\n\n\nconst largestComponent = (graph) => {\n\tlet largest=0;\n\t//keep a track of visited nodes\n\tlet visited =  new Set();\n\n\t// loop through the graph object\n\tfor (node in graph) {\n\t\tif(visited.has(String(node))) continue;\n\t\tlet currentCount = DFS(graph, node, visited);\n\t\tlargest = Math.max(largest, currentCount);\n\t}\n\n\treturn largest;\n\n}\n\nconst DFS = (graph, node, visited) => {\n\n\tlet currentCount = 1;\n\tlet stack = [node];\n\n\twhile(!!stack.length){\n\n\t\tlet current = stack.pop();\n\t\tfor( neighbor of graph[current]){\n\n\t\t\tif(visited.has(String(neighbor))) continue;\n\t\t\tstack.push(neighbor);\n\t\t\tvisited.add(String(current));\n\t\t\tcurrentCount++;\n\n\t\t}\n\n\t}\n\n\treturn currentCount;\n}\n\n\nconsole.log(largestComponent({\n  0: ['8', '1', '5'],\n  1: ['0'],\n  5: ['0', '8'],\n  8: ['0', '5'],\n  2: ['3', '4'],\n  3: ['2', '4'],\n  4: ['3', '2']\n}))", "likes": 0}, {"author": "Asami Tam", "text": "You are such an amazing educator and programmer. Thank you so much!", "likes": 0}]}, {"topLevelComment": {"author": "Dajjal", "text": "const graph = {\n  a: ['b', 'c'],\n  b: ['d'],\n  c: ['e'],\n  d: [],\n  e: ['b'],\n  f: ['d'],\n}\nAbove graph DFS is not correct as per the algorithm discussed, please clarify", "likes": 0}}, {"topLevelComment": {"author": "Ana Paula", "text": "Fantastic. Thank you so much for this amazing explanation!", "likes": 2}}, {"topLevelComment": {"author": "aura", "text": "aKsHiTa", "likes": 0}}, {"topLevelComment": {"author": "Josh", "text": "When I did leetcode, this does not pass all tests. By changing colInBounds to 0 <= c && c < grid[0].length; it all passed. Also, you could save a bit more memory by taking away the visited and have grid[r][c] = 'W' in place of visited.add, etc and put those variables in the recursive function instead of visited. Regardless, I learned a lot. Thank you.", "likes": 0}}, {"topLevelComment": {"author": "katerin perdom", "text": "Thank you so much for this video\nHelp me a lot \ud83e\udd70", "likes": 0}}, {"topLevelComment": {"author": "Shahrin Nakkhatra", "text": "34:27 How's that n^2? I mean, if you take 3 nodes, then the permutation is 3P2 = 6. I don't think that it's possible to make 9 edges with 3 nodes. Please correct me if I'm wrong.", "likes": 0}, "replies": [{"author": "Shahrin Nakkhatra", "text": "I guess he didn't mean that it should be exactly n^2, rather the max degree of the polynomial should be 2 for the number of edges. For directed graphs, max no. of edges should be, nP2 = n!/ (n-2)! = n(n-1)(n-2)...3.2.1/ (n-2)(n-3)...3.2.1 = n(n-1) = n^2-n ~ O(n^2)", "likes": 0}]}, {"topLevelComment": {"author": "Amit Kundu", "text": "I am following Alvin's last couple of series DP, Graph.  Really enjoying his teaching. Appreciate.", "likes": 0}}, {"topLevelComment": {"author": "mahesh kokare", "text": "Who the Hell are you to teach Graphs in this outstanding way....Fear of Heights can overcome by visiting cliff and Fear of Graphs can overcome by going through your Videos. I am speechless", "likes": 0}}, {"topLevelComment": {"author": "Coding Warlock", "text": "Great Explanations", "likes": 0}}, {"topLevelComment": {"author": "sam wilson", "text": "this man is the greatest DS&ALG teacher ever", "likes": 0}}, {"topLevelComment": {"author": "Mohamed Siddic", "text": "Hey Man its gem thanks a lot. Now graph in my deep memory. Please help me to get the other course video you did.", "likes": 0}}, {"topLevelComment": {"author": "Menugonda Pavan Kumar", "text": "explanation - simply \"woww\"", "likes": 0}}, {"topLevelComment": {"author": "Peter Rocc", "text": "(Revelation 20:11-15)And I saw a great white throne, and him that sat on it, from whose face the earth and the heaven fled away; and there was found no place for them. And I saw the dead, small and great, stand before God; and the books were opened: and another book was opened, which is the book of life: and the dead were judged out of those things which were written in the books, according to their works. And the sea gave up the dead which were in it; and death and hell delivered up the dead which were in them: and they were judged every man according to their works. And death and hell were cast into the lake of fire. This is the second death. And whosoever was not found written in the book of life was cast into the lake of fire. (Revelation 20:11-15)", "likes": 0}}, {"topLevelComment": {"author": "Neha Bhagchandani", "text": "This was really helpful! Thank you very much!", "likes": 0}}, {"topLevelComment": {"author": "Yogesh Ulhe", "text": "Hey Alvin Awesome video on Graph Algorithm", "likes": 0}}, {"topLevelComment": {"author": "Code Pandit", "text": "Mast", "likes": 0}}, {"topLevelComment": {"author": "Siddhant Jagdish", "text": "THANK YOU!!", "likes": 0}}, {"topLevelComment": {"author": "Sai Adigoppula", "text": "graphs are easy then I thought", "likes": 0}}, {"topLevelComment": {"author": "Sandman", "text": "Is n^2 edges or 2n edges?", "likes": 0}}, {"topLevelComment": {"author": "Towfiq Rafi", "text": "When our graph node is empty, during for loop Python shows None Key error. How to solve it?", "likes": 0}}, {"topLevelComment": {"author": "Sas Kirakosyan", "text": "Great course. Thanks", "likes": 0}}, {"topLevelComment": {"author": "Las Ranas Malevolas", "text": "1:39:30", "likes": 0}}, {"topLevelComment": {"author": "Deepak kumar pandey", "text": "One thing to keep in mind for javascript is when you are using queue the shift operation on array is of O(n) complexity. to make it O(1) you need to implement circular queue class yourself.", "likes": 0}}, {"topLevelComment": {"author": "Fiifi yawson", "text": "I am a little bit confused with the recursive functions written inside the for loops and while loops. I want to know, won't visited be reset on each iteration of the loops?", "likes": 0}, "replies": [{"author": "Live TV", "text": "No, because objects are passed as referenced. so basically we are passing the same object to all the recursive functions which update the same object by the function stack by stack.", "likes": 0}]}, {"topLevelComment": {"author": "Ritwik Shivam", "text": "Some doubt-\n52:15 code line number 9 why are you taking only [a, b] it might be the case when where each nested list would have different number of string or say '[[a1,a2,a3], [a1,a2], [a2,a3,a4].......], any general approach to handle that, please suggest\n1:15:08 for the problem Largest component of graph - Can we just count the length of array which is the key associated with  node in graph dictionary, Python approach\ndef lengthOfLargestCompoent(graph):\r\n     ans = []\r\n     for node in graph:\r\n          ans.append(len(graph[node])+1)\n\n     return max(ans)", "likes": 0}}, {"topLevelComment": {"author": "Ritwik Shivam", "text": "Amazing video great effort, quality, superb", "likes": 0}}, {"topLevelComment": {"author": "Mohamed A. Ahmed", "text": "This was clutch yo I got an interview in 2 days \ud83d\ude2d\ud83d\ude02", "likes": 0}}, {"topLevelComment": {"author": "briansyoutubechannel", "text": "A little confused how the worst case graph with 3 nodes at 34:26 has 6 total edges, which is not equal to n^2?", "likes": 0}}, {"topLevelComment": {"author": "ptreeful", "text": "Sorry, for spoiling the impression, but there are two moments.\nFirst: in DFS and BFS in fact you traverse tree. And if there is a cycle in a graph it\u2019s not clear how to process it\nSecond: in hasPath you say that number of edges would be n^2, but in worst case you have 3 nodes and 6 edges! Number of pairs would be C n 2, or (n 2) I suppose, and as we have 2 directions, then we need to multiply that by 2.", "likes": 0}}, {"topLevelComment": {"author": "Famous Badger", "text": "This is a great video! Just an observation - when counting islands following the logic in this video - going to a neighbor above at [r -1][c] is redundant, since we are descending throughout the run, and it's impossible to encounter an unvisited 'L' box in the row above the current one. We only need neighbors at the right, bottom and left.", "likes": 0}}, {"topLevelComment": {"author": "Meshkat Shadik", "text": "A simple trick would help to get the calculations more faster.\n\nmy approach of Island counting problem:\nvar numIslands = function(grid) {\n    let count = 0;\n    for(let r=0; r<grid.length; r++){\n        for(let c=0; c<grid[0].length;c++){\n            if(islandFound(grid,r,c)===true){\n                count++;\n            }        \n        }\n    }\n    return count;\n};\n\nconst islandFound = (grid,r,c) =>{\n    const rowBound = 0<= r && r<grid.length;\n    const colBound = 0<= c && c<grid[0].length;\n    \n    if(!rowBound ||!colBound) return false;\n    if(grid[r][c] === 'W' || grid[r][c] === 'X') return false;\n    else{\n        grid[r][c]='X';\n    }\n    islandFound(grid,r-1,c);\n    islandFound(grid,r+1,c);\n    islandFound(grid,r,c-1);\n    islandFound(grid,r,c+1);\n    \n    return true;\n}\n\n\nInstead of using set, I just make the visited land as 'X' and catch the condition with 'W' checking block. \ud83d\ude06\ud83d\ude06\n\nTHIS APPROACH CAN BE USED IN OTHER VISITED TYPE SOLUTION'S ALSO.", "likes": 0}}, {"topLevelComment": {"author": "Famous Badger", "text": "34:28 - I think the worst case of 3 nodes with 6 edges is not a good example of n = # nodes and n^2 = # edges.", "likes": 0}}, {"topLevelComment": {"author": "Alberto Miranda", "text": "Can't believe this is free!! This info would cost hundreds at my university. Great content \ud83d\udc4d", "likes": 0}}, {"topLevelComment": {"author": "Sebasti\u00e1n Jara Uribe", "text": "\u00a1Gracias!", "likes": 0}}, {"topLevelComment": {"author": "Quadri Abolarinwa", "text": "Alvin, you\u2019re one of a kind. Thanks", "likes": 0}}, {"topLevelComment": {"author": "Tess Zheng", "text": "at 01:45:00 , when doing island count, we can actually change the grid[r][c] from 'L' to 'W' when exploring island, so we don't need to use a set to track which node has been visited", "likes": 0}}, {"topLevelComment": {"author": "Vince P", "text": "Why on earth would you choose JS for this? Python is the OBVIOUS choice.", "likes": 0}}, {"topLevelComment": {"author": "Aaron Biliyok", "text": "I love you for real!!!!!!!!", "likes": 0}}, {"topLevelComment": {"author": "marie laure Debeaune", "text": "many thanks for this video. How do you do the same thing in C#?", "likes": 0}}, {"topLevelComment": {"author": "Varma", "text": "Very nice and intuitive explanation.", "likes": 0}}, {"topLevelComment": {"author": "Franco Giuliano Pertile", "text": "Awesome Video", "likes": 0}}, {"topLevelComment": {"author": "Blue Skies", "text": "Is there any resources you guys have on matrices? for example, rotating a 2d matrix?", "likes": 0}}, {"topLevelComment": {"author": "Igor Popov", "text": "content is 10/10, but js syntax is a nightmare :D", "likes": 0}}, {"topLevelComment": {"author": "Goblin Moblin", "text": "I really enjoyed this course.", "likes": 0}}, {"topLevelComment": {"author": "Aashutosh Murthy", "text": "1:45:05\nThe space complexity of O(r * c) can be reduced to O(1) by just marking the land L we visit as water W? That way, we would ignore any land we have seen before just like we would ignore water, thereby saving space.", "likes": 0}}, {"topLevelComment": {"author": "Gabriel Vaz", "text": "Very good class", "likes": 0}}, {"topLevelComment": {"author": "Nom9d", "text": "thanks a lot!!!", "likes": 0}}, {"topLevelComment": {"author": "Vincent Hou", "text": "The series of your videos are amazing. They are the best courses I have ever seen regarding data structure and algorithm studies. However, I do think I find out a potential mistake. At 1:53:55, check the line 12, const colInbounds = 0 <= c && c< grid.length. Technically, the number of the columns could be different from the number of the rows, so this line should be const colInbounds = 0 <= c && c< grid[0].length, grid[0] must exist for sure. Or, pass the number of columns as argument for this function.", "likes": 0}}, {"topLevelComment": {"author": "Raj singh", "text": "Great course, I loved it! But how was it decided for the island count problem to use depth first traversal instead of breadth first? What is the logic behind that?", "likes": 0}}, {"topLevelComment": {"author": "Jayanta Samaddar", "text": "Breadth-first is also possible recursively. Here's the solution:\n\n/** Breadth-First Search - Recursive Method */\nfunction bfsRecursive(graph, source) {\n  if (!Object.keys(graph)?.length || !graph?.[source]) return null;\n  else {\n    function search(Q, result = []) {\n      if (Q.length === 0) return result;\n      const node = Q.shift();\n      result.push(node);\n      for (let i = 0; i < graph[node].length; i++) {\n        Q.push(graph[node][i]);\n      }\n      return search(Q, result);\n    }\n    return search([source]);\n  }\n}\n\n// Result: [ 'a', 'b', 'c', 'd', 'e', 'f' ]", "likes": 0}}, {"topLevelComment": {"author": "Max Ax", "text": "great for beginning!!!!", "likes": 0}}, {"topLevelComment": {"author": "Shafana Safwan", "text": "best source of graphs I found so far.", "likes": 0}}, {"topLevelComment": {"author": "Apple", "text": "thanks for posting this course. Very practical and concise. Great job!", "likes": 0}}, {"topLevelComment": {"author": "sumedha j", "text": "Thanks so much for uploading this! The approaches are clearly explained", "likes": 0}}, {"topLevelComment": {"author": "OEThe11", "text": "This was an elite video. I did the last two questions and did not understand how to approach it or understood what the right answer for those questions. Watch the 2+ hours of video as well as coding it up myself, and everything makes sense. EVERYTHING. I am now able to do one of the toughest topics that I was having trouble with. So BIG Thank You for that. \n\nP.S. For the last 2 questions, you don't need the visited set, you can flip the land to water or another value altogether. Avoiding the cyclic infinite loop.", "likes": 2}}, {"topLevelComment": {"author": "Amandeep singh jaura", "text": "Great course and learned alot.\nJust a heads-up, we should never use Array as Queues in production problem instead we can use Linked List.\nAs removing a value from start of the array has o(n) time complexity as we have to re-index again and Queue should have constant time complexity for adding and removing an element.", "likes": 2}}, {"topLevelComment": {"author": "Matt Hou", "text": "excellent video, good work Alvin", "likes": 0}}, {"topLevelComment": {"author": "Raj Dwivedy", "text": "at 34:30 shouldn't it be O(2n)..for 4 edges it becomes O(3n).. please clarify i might be wrong .. was never good with the big O", "likes": 0}}, {"topLevelComment": {"author": "Igor The Overlord", "text": "Python iterative solution to connected components count\n\ndef connected_components_count(graph):\n    stack = []\n    visited = set()\n    n = 0\n    count = 0\n    while n != len(graph):\n        for key in graph:\n            n += 1\n            if key in visited:\n                continue\n            stack.append(key)\n            current = stack.pop()\n            for node in graph[current]:\n                if node not in visited:\n                    visited.add(node)\n                    stack.append(node)\n            count += 1\n    return count\ngraph = {\n    0: [8, 1, 5],\n    1: [0],\n    5: [0, 8],\n    8: [0, 5],\n    2: [3, 4],\n    3: [2, 4],\n    4: [3, 2],\n}\nprint(connected_components_count(graph))", "likes": 0}}, {"topLevelComment": {"author": "Igor The Overlord", "text": "Python iterative solution to undirected path problem\n\ndef undirected_path(graph, source, target):\n    visited = set()\n    queue = [source]\n    while queue:\n        current = queue.pop(0)\n        if current == target:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return False\ngraph = {\n    'i': ['j', 'k'],\n    'j': ['i', 'k'],\n    'k': ['i', 'm', 'l', 'j'],\n    'm': ['k', 'p'],\n    'l': ['k'],\n    'o': ['n'],\n    'n': ['o'],\n    'p': ['m']\n}\nprint(undirected_path(graph, 'j', 'p'))", "likes": 0}}, {"topLevelComment": {"author": "Tiyen", "text": "Thank you for the video. Also to find the minimum sizes of the island, we can use the method that calls the recursive function (parent method) to hold an integer that points to the size of the visited set before the recursive call and then use the difference in size after the recursive call to determine the minimum size. This to me didn't require me to create a new recursive method that returns an integer. However, creating an extra method does have its benefits too.", "likes": 0}}, {"topLevelComment": {"author": "Suraj Shah", "text": "Great tutorial Alvin. For python programmers, here is the pattern for largest components (connected components is similar):\n\ndef explore(arr, node, visited, comp_count):\n    if node in visited:\n        return 0, visited\n    \n    visited[node] = 1\n    for neighbour in arr[node]:\n        comp_count += 1\n        explore(arr, neighbour, visited, comp_count)\n        \n    return comp_count, visited\n    \ndef largestcomponent(arr):\n    largest_comp = 0\n    visited = {}\n    \n    for node in arr:\n        if node not in visited:\n            comp_count, visited_new = explore(arr, node, visited, 1)\n            visited = visited_new\n\n            if comp_count > largest_comp:\n                largest_comp = comp_count\n\n    return largest_comp", "likes": 0}}, {"topLevelComment": {"author": "Daniyal Kabir", "text": "This is super helpful! Thank you!", "likes": 0}}, {"topLevelComment": {"author": "Mr. Anonymous", "text": "Shouldn't the time complexity be O(n + e)?", "likes": 0}}, {"topLevelComment": {"author": "PotatoCoder", "text": "I have a question. If the number of nodes in a graph is n, then in the worst case, would the number of edges be n^2 or would they be 2*n?", "likes": 0}}, {"topLevelComment": {"author": "Pandey Aashish", "text": "Preprocessing the input by storing edges in hashmap: this line took all my fears of not even trying to attempt graph problems to making me feel I could do any graph problems. Thanks for this video \u2764\ufe0f", "likes": 0}}, {"topLevelComment": {"author": "minciNashu", "text": "34:04 E = N*(N-1) for directed graphs. So in that example, 3 nodes means 6 edges (not 9, as in 3 squared)", "likes": 0}}, {"topLevelComment": {"author": "F. U. Spammers", "text": "Dude I absolutely love the graphics in the beginning, which absolutely MAKE this video the one that helps me understand. For FOR F&#K'S SAKE, stop obsessing over the output order. You keep interrupting the flow of understanding EVERY TIME to obsess over whether it's a,b,c or a,b,d, who gives a flying chip. Yes, yes, I understand we're taking a new branch. But I'm just trying to understand the basic flowchart of your code, for which abc/abd is utterly irrelevant and distracting and you keep touting it endlessly like it will make a difference to understanding the basic steps for traversal. It won't!", "likes": 0}}, {"topLevelComment": {"author": "70 Da", "text": "I like this course ,Thank you \")", "likes": 0}}, {"topLevelComment": {"author": "Jerin John Kachirackal", "text": "This is really really a complete tutorial for \u201cGraph based Problems\u201d both in terms of coding Problems, interview preperation including MAANG and even for a new bie.", "likes": 0}}, {"topLevelComment": {"author": "Dominic Amodeo Lee", "text": "very useful", "likes": 0}}, {"topLevelComment": {"author": "Jerin John Kachirackal", "text": "Perfect content", "likes": 0}}, {"topLevelComment": {"author": "hemil patel", "text": "Best video on graphs I have ever seen .", "likes": 0}}, {"topLevelComment": {"author": "Andr\u00e9 Padez", "text": "On your solution for \"islandCount\" there is a mistake: the tests only pass because the inputs are all squared matrixes. Line 15 should be you should be testing 'c' against 'grid[0].length', not just 'grid.length'", "likes": 3}}, {"topLevelComment": {"author": "Nadiia Heckman", "text": "IslandCnt implementation is elegant beyond words.", "likes": 0}}, {"topLevelComment": {"author": "DIY By Joji", "text": "You are awesome bro. \ud83d\ude0d\ud83d\ude0d", "likes": 0}}, {"topLevelComment": {"author": "nezzari yasser", "text": "much appreciated !!!!", "likes": 0}}, {"topLevelComment": {"author": "pankajdnb", "text": "Can you please make a video on the method you are using for testing the program? Any framework that you prefer for testing such as JEST?", "likes": 1}}, {"topLevelComment": {"author": "RamanSB100", "text": "How come for hasPath he didn't keep track of the nodes he had already visited?", "likes": 0}}, {"topLevelComment": {"author": "Roger Perez", "text": "I'm only half way through the course it I'm \ud83e\udd2f on how i'm clearly understanding graphs. Now to practice", "likes": 0}}, {"topLevelComment": {"author": "Sergii M", "text": "Amazing introduction to graphs! Very well explained !", "likes": 0}}, {"topLevelComment": {"author": "bambamgam", "text": "Huge fan of these courses, he's a great teacher and breaks down these problems to be far less intimidating", "likes": 0}}, {"topLevelComment": {"author": "Aya", "text": "pure gold!", "likes": 0}}, {"topLevelComment": {"author": "tagakosmos", "text": "solve all leetcode problems", "likes": 0}}, {"topLevelComment": {"author": "Debangshu Paul", "text": "Great work brother", "likes": 0}}, {"topLevelComment": {"author": "brberis", "text": "Great video, thank you.\nWhy are you using arrow functions?", "likes": 0}}, {"topLevelComment": {"author": "Aditya Byreddy", "text": "This is amazing. I found it really easy to understand the graph algorithms after referring to this video. Great job, Alvin :)\n\nSmall correction in the solution described for checking if a source and destination have a path in an undirected graph. (line no. 8)\n\nThe logic of traversing the neighbors and adding the source node to the visited list has to be part of the condition that validates whether ta node is visited or not.\n\nif !(visited.has(src)) {\n  // add the src to the visitors list\n  // recursively traverse through the src neighbors\n}", "likes": 5}}, {"topLevelComment": {"author": "Damian", "text": "Regarding to 1:55:50, when you say that you \u201cI don\u2019t look before I leap\u201d, if the algorithm was using bfs, the space complexity of the queue becomes O(edges) instead of O(nodes), right? Because you will potentially add a given node many times if different nodes at the same level have an edge to it, even when it is processed only the first time is polled and the other times will be ignored.", "likes": 0}}, {"topLevelComment": {"author": "Ben L", "text": "please do a similar video for weighted graphs. alvin has the best teaching style. clear concise with helpful drawings!!!", "likes": 0}}, {"topLevelComment": {"author": "Satyajit Mishra", "text": "nice explanation in teaching", "likes": 0}}, {"topLevelComment": {"author": "Serge Kamga", "text": "What editor are you using?", "likes": 0}, "replies": [{"author": "XZalla", "text": "The editor is on https://www.structy.net/", "likes": 0}]}, {"topLevelComment": {"author": "Mohammed Thavaf", "text": "amazing teaching skills man. thank you <3", "likes": 0}}, {"topLevelComment": {"author": "FastDrop", "text": "Excellent video! Thank you!", "likes": 0}}, {"topLevelComment": {"author": "Shyamu Yadav", "text": "Thanks!", "likes": 0}}, {"topLevelComment": {"author": "daniel gunawan", "text": "shouldn't the time complexity for haspath be O(V+E), since it is just another dfs/bfs?", "likes": 1}}, {"topLevelComment": {"author": "Live2Code", "text": "Thx a lot for your couse!! great explanation!", "likes": 0}}, {"topLevelComment": {"author": "Arjit Shrivastava", "text": "46:13", "likes": 0}}, {"topLevelComment": {"author": "Andrew Ohiienko", "text": "I presume on https://youtu.be/tWVWeAqZ0WU?t=7101 should be \nconst colInbounds = 0 <= c && c < grid[0].length;\ninstead of\nconst colInbounds = 0 <= c && c < grid.length;", "likes": 0}}, {"topLevelComment": {"author": "manivannan sivaraj", "text": "Thanks for this video tutorial, Alvin!\nIt helped me to understand graphs, graph traversals and most common graph related tech interview problems much better.", "likes": 0}}, {"topLevelComment": {"author": "Graym", "text": "helpful", "likes": 0}}, {"topLevelComment": {"author": "Bikki Kumar sha", "text": "Changing lives, one algorithm at a time. Great work Alvin!", "likes": 2}}, {"topLevelComment": {"author": "Soorya Prakash", "text": "Thank you for the video!", "likes": 0}}, {"topLevelComment": {"author": "ybelsare", "text": "Exceptional .. you have a lovely voice and narration style", "likes": 0}}, {"topLevelComment": {"author": "Sam Azadi", "text": "i love how clean the approach to BFS is here. I have a question - does anyone have examples of how we can do the same with a Node type rather than being given the graph as an array. i.e we're given a Node with left and right children, how do we use this same approach for BFS in this case?", "likes": 1}, "replies": [{"author": "Prashant Godara", "text": "Hi Sam,\nIn case of left and right node you can add the nodes in queue directly after checking visited set.\nJava eg- \nqueue.offer(head);\nwhile (!queue.isEmpty()){\n             TreeNode visiting = queue.poll();\n             System.out.println(visiting.val);\n             if(visiting.left != null && !visited.contains(visiting.left)){\n              queue.offer(visiting.left);\n              visited.add(visiting.left);\n             }\n            if(visiting.right != null && !visited.contains(visiting.right)){\n             queue.offer(visiting.right);\n              visited.add(visiting.right);\n            }\n        }\n\nHope this helps!!", "likes": 0}]}, {"topLevelComment": {"author": "Feng Liu", "text": "Oh the keys being converted to string has to do with javascript preamptively assuming you want to work with it serialized and ready to go over the web as a json.", "likes": 0}}, {"topLevelComment": {"author": "Sushant Thakur", "text": "Thanks!", "likes": 0}}, {"topLevelComment": {"author": "IntCoder", "text": "You are the man!! Thanks for these tutorials!! The are great!!!", "likes": 1}}, {"topLevelComment": {"author": "Philip Debrah", "text": "Awesome!", "likes": 0}}, {"topLevelComment": {"author": "iCH4N6", "text": "amazing video on graphs. Relearning graphs now and this has been very useful. Thank you!", "likes": 0}}, {"topLevelComment": {"author": "Ratheesh R", "text": "Best crash course!", "likes": 0}}, {"topLevelComment": {"author": "Ratheesh R", "text": "Best course!", "likes": 0}}, {"topLevelComment": {"author": "Ratheesh R", "text": "Best Video!", "likes": 0}}, {"topLevelComment": {"author": "simonlchilds1", "text": "this is such a great video, thank you!", "likes": 0}}, {"topLevelComment": {"author": "spurthi rao", "text": "Thanks for making the graph problems easy!", "likes": 0}}, {"topLevelComment": {"author": "Dev Jeff", "text": "Thank you soooo much !!! You explained everything in a more simple and concise way !!!!", "likes": 0}}, {"topLevelComment": {"author": "A Little Coding", "text": "really helpful", "likes": 0}}, {"topLevelComment": {"author": "Alaa Radwan", "text": "this easy smooth explanation of graph is realy helpful , realy like it , thanks for your efforts", "likes": 0}}, {"topLevelComment": {"author": "Hasan", "text": "Excellent explanation. Will implement these algorithms in Python for practice.", "likes": 0}}, {"topLevelComment": {"author": "kreo debunk", "text": "on 2d grid, you can count islands more efficiently, with shallow algorithm. Found begin and end of island fragments for each row and then match rows of begins and ends", "likes": 0}}, {"topLevelComment": {"author": "Rob Malford", "text": "Ah JavaScript; where const does not mean const at all and no one is really sure why it's even there.", "likes": 0}}, {"topLevelComment": {"author": "Mahabub Karim", "text": "Why the time complexity is O(e) for has path, not O(V+E)???  \ud83e\udd14\ud83e\udd14\ud83e\udd14, Explain please...", "likes": 0}}, {"topLevelComment": {"author": "Jimmy Bellmon", "text": "So Breathe First Traverse is the Fibonacci \ud83e\udd14\ud83d\udc4d\ud83c\udffe", "likes": 0}}, {"topLevelComment": {"author": "Modern Teenage Investor", "text": "Great explainer, the fact that this type of content is free is truly amazing", "likes": 0}, "replies": [{"author": "kreo debunk", "text": "it is primitive. no dujksra/a*/ minimum spanning tree is mentioned :D", "likes": 0}]}, {"topLevelComment": {"author": "gaurav sharma", "text": "This is an amazing tutorial on graph theory!!!", "likes": 0}}, {"topLevelComment": {"author": "Priyanshu", "text": "34:37  i think ther is 2n not n^2  and time complexity  is n", "likes": 0}}, {"topLevelComment": {"author": "Symbol", "text": "The best beginner graph tutorial.\nI always come back to this to refresh myself on graphs.", "likes": 0}}, {"topLevelComment": {"author": "Devendra Chauhan", "text": "Really well explained \ud83d\udc4d", "likes": 0}}, {"topLevelComment": {"author": "Jay P", "text": "I learned more from this tutorial then all other tutorials that I watched combined. Great videos man!", "likes": 0}}, {"topLevelComment": {"author": "Jacob Moore", "text": "For the shortest path algorithm, finding the length of the shortest path is helpful of course but shouldn't we be returning the path itself? That's arguably the most important feature.", "likes": 1}, "replies": [{"author": "Jacob Moore", "text": "@HaZe Have you heard of Logistics by chance?", "likes": 0}, {"author": "HaZe", "text": "No because you mistakely think these kind of problems have any real world use", "likes": 0}]}, {"topLevelComment": {"author": "Sai Nagarjuna", "text": "The best course for beginners", "likes": 0}}, {"topLevelComment": {"author": "Gagandeep singh Madaan", "text": "Thanks so much for this open source video. Highly appreciate your efforts. \nAre there any further videos on Greedy Algorithms, Cyber security , BLE basics ?", "likes": 0}}, {"topLevelComment": {"author": "M", "text": "Thanks to the first 30mins of this video alone I was able to extend the idea of adjacency lists and independently solve all the following problems on undirected graphs and grid graphs in just under a week's worth of practice", "likes": 0}}, {"topLevelComment": {"author": "osagie osemwota", "text": "hello please i need help...on the Largest Component question, i decided to not use the recursive method in my DFS function but i am stuck in a bug... Every single one of the test cases on structy works except the first...here is my code  : \n\n// Write a function, largestComponent, that takes in the adjacency list of an undirected graph. The function should return the size of the largest connected component in the graph.\n\n\nconst largestComponent = (graph) => {\n\tlet largest=0;\n\t//keep a track of visited nodes\n\tlet visited =  new Set();\n\n\t// loop through the graph object\n\tfor (node in graph) {\n\t\tif(visited.has(String(node))) continue;\n\t\tlet currentCount = DFS(graph, node, visited);\n\t\tlargest = Math.max(largest, currentCount);\n\t}\n\n\treturn largest;\n\n}\n\nconst DFS = (graph, node, visited) => {\n\n\tlet currentCount = 1;\n\tlet stack = [node];\n\n\twhile(!!stack.length){\n\n\t\tlet current = stack.pop();\n\t\tfor( neighbor of graph[current]){\n\n\t\t\tif(visited.has(String(neighbor))) continue;\n\t\t\tstack.push(neighbor);\n\t\t\tvisited.add(String(current));\n\t\t\tcurrentCount++;\n\n\t\t}\n\n\t}\n\n\treturn currentCount;\n}\n\n\nconsole.log(largestComponent({\n  0: ['8', '1', '5'],\n  1: ['0'],\n  5: ['0', '8'],\n  8: ['0', '5'],\n  2: ['3', '4'],\n  3: ['2', '4'],\n  4: ['3', '2']\n}))", "likes": 0}}, {"topLevelComment": {"author": "Amir", "text": "stg I have to learn JavaScript to learn C++ lmao", "likes": 0}}, {"topLevelComment": {"author": "ANTHONY LUGO", "text": "The course on DP was a winner. Course on Graph algo is another winner. Hope to learn a lot more from you.", "likes": 0}}, {"topLevelComment": {"author": "M", "text": "Alvin you have just explained in 30mins what I tried and failed to learn from google in 30days!", "likes": 0}}, {"topLevelComment": {"author": "M", "text": "I have wasted years of time on google learning to code when I should have come straight to this youtube channel", "likes": 0}}, {"topLevelComment": {"author": "ujjwal jain", "text": "island code : \nvar numIslands = function(grid) {\r\n    let islandCount = 0;\r\n    for (let i = 0; i < grid.length; i++) {\r\n        for (let j = 0; j < grid[0].length; j++) {\r\n            if (grid[i][j] === '1') {\r\n                islandCount += dfs(i, j, grid);\r\n            }\r\n        }\r\n    }\r\n    return islandCount\r\n};\r\n\r\nconst dfs = (i, j, grid) => {\r\n    if (invalidCell(i, j, grid) || grid[i][j] !== '1') return // no need to process these cells\r\n    grid[i][j] = '#' // mark visited nodes so we dont count again \r\n    dfs(i - 1, j, grid)\r\n    dfs(i + 1, j, grid)\r\n    dfs(i, j - 1, grid)\r\n    dfs(i, j + 1, grid)\r\n    return 1 // now we've processed the whole island, return 1 to add to our count\r\n}\r\n    \r\nconst invalidCell = (i, j, grid) => i < 0 || i >= grid.length || j < 0 || j >= grid[0].length", "likes": 0}}, {"topLevelComment": {"author": "Anthony Park", "text": "just wow on the fact that we're living in a world where we have access to such a quality learning material for FREE. Thanks a lot!!", "likes": 0}}, {"topLevelComment": {"author": "Agustin Vargas", "text": "This is fantastic. Makes graphs easy to digest. Thanks for that.\n\nI did find a minor issue in the island count problem solution.\n\nIt assumes that each row will have the same number of columns. That assumption isn't described in the problem. So a quick fix would be to run the nested loop to the length of the row instead of fixing it to zero. And doing the same for the inbounds check. That would present an issue in the exploration in that there might not be any map in either direction, so you'll have to add an existence check in the explore to account for that.\n\nThis way if a row has less coordinates, or more, it would still work properly.", "likes": 1}}, {"topLevelComment": {"author": "ujjwal jain", "text": "Thanks for this tutorial !!", "likes": 0}}, {"topLevelComment": {"author": "Udit Verma", "text": "I search for videos where Alvin is the tutor \ud83d\ude02", "likes": 0}}, {"topLevelComment": {"author": "K D", "text": "Honestly probably the best explanations for DS&A", "likes": 0}}, {"topLevelComment": {"author": "Mohib", "text": "one of the best instructors. what a beast", "likes": 0}}, {"topLevelComment": {"author": "Th\u1ecd Hu\u1ef3nh", "text": "Thanks for the great course !!! But I don\u2019t understand why in worst case, number of edge will be equal to square of number of nodes? Should it be (number of node)z! in 2-way graph?", "likes": 0}}, {"topLevelComment": {"author": "Best Quotes", "text": "Can anyone explain When will the while loop condition get failed?", "likes": 0}}, {"topLevelComment": {"author": "dan mus", "text": "if all teachers were like Alvin, everyone would have a PhD in computer science", "likes": 2}}, {"topLevelComment": {"author": "RoastedFriedGrilled", "text": "Keep learning...Keep growing", "likes": 0}}, {"topLevelComment": {"author": "Michael Branconier", "text": "Thanks for the video!!", "likes": 0}}, {"topLevelComment": {"author": "reactdev 2020", "text": "Very good course", "likes": 0}}, {"topLevelComment": {"author": "Alex Neagoe", "text": "I am actually studying C but I have found this video tremendeously helpfull in explaining how graphs are traversed and how not to use return in a bad way when you want to actually make use of recursion to backpedal from dead ends in situations where you don't find your base case.\n\nthank you again. subscribed!", "likes": 2}}, {"topLevelComment": {"author": "Paddy D", "text": "He is the guy", "likes": 0}}, {"topLevelComment": {"author": "Amit Dey", "text": "Really good", "likes": 0}}, {"topLevelComment": {"author": "Thakur Yogeshwar Singh", "text": "What a great series! Learnt so much in just under 2 hours!", "likes": 0}}, {"topLevelComment": {"author": "Jerald Macachor", "text": "Leetcode - O(n^2) brute force.\nAlgoexpert - O(n) linear\nAlvin / Structy - log(n)", "likes": 39}}, {"topLevelComment": {"author": "RoniFinTech", "text": "amazing walk-throughs!", "likes": 0}}, {"topLevelComment": {"author": "Kishore Kumar", "text": "You just made me crack my Interview on graph algorithms... and I have just seen half the video only to make it... Thanks a ton Bro... Let me complete this", "likes": 0}}, {"topLevelComment": {"author": "Code Cleric", "text": "I thought I'd seen the all the greatest of online coding instructors, and then I found Alvin... Seriously these explanations are paced exactly perfectly and ultra clear", "likes": 0}}, {"topLevelComment": {"author": "Ben Sang", "text": "You teach so well this is the future of education!", "likes": 0}}, {"topLevelComment": {"author": "Aravind Sanjeev", "text": "25:25 I don't understand how iteration will still continue after the it hits the first empty array?  Like once it hits f, how does it restart from c?\n\nEdit: well, i figured it out :)", "likes": 0}}, {"topLevelComment": {"author": "Michael Vigato", "text": "Woudln't it be \"easier\" to use JS Maps instead of regular JS objects for stuff like adjacency lists?", "likes": 0}}, {"topLevelComment": {"author": "Niki", "text": "This is the only course I\u2019ve found that has successfully got the concept of graphs through my thick skull, it\u2019s been a subject that\u2019s been so hard for me to learn. Thank you for making this!!", "likes": 5}}, {"topLevelComment": {"author": "Tabrez khan", "text": "Thanks \ud83d\udc4d\ud83c\udffc", "likes": 0}}, {"topLevelComment": {"author": "Harshit Choudhary", "text": "Amazing content :)", "likes": 0}}, {"topLevelComment": {"author": "Content Karishma", "text": "nice video :)", "likes": 0}}, {"topLevelComment": {"author": "Eliyahu Levy", "text": "this guy is the best teacher  there is. \nThank you so much!\nI have subscribed to your chanel (:", "likes": 0}}, {"topLevelComment": {"author": "Randomisticful", "text": "Einstein once said \"If you are able to explain it to a 5 year old, you understand it yourself\". Alvin, you are one of a kind!", "likes": 21}}, {"topLevelComment": {"author": "Jaleel Douglas", "text": "Finished my very first fCC course. The pedagogy is excellent, Alvin is a great teacher", "likes": 0}}, {"topLevelComment": {"author": "Mithila Navishka", "text": "I need Advice From You! \n\nI have few input files which included maze, if i want find shortest path of that maze, i have to convert that maze file in to adjacency l list or matrix right? or is there other way i can do it, please advise me regarding this", "likes": 0}}, {"topLevelComment": {"author": "Sivagami Subramanian Nambi", "text": "Only love <3, have never understood this well!!", "likes": 0}}, {"topLevelComment": {"author": "Robert Volgman", "text": "Should be noted that the algorithms used in part 1 only work for directed ACYCLIC graphs. They will loop forever in a graph that has any cycles.", "likes": 0}}, {"topLevelComment": {"author": "Amitav", "text": "thanks for providing suck elegant solutions, i was doing Map and really complicating my code,", "likes": 0}}, {"topLevelComment": {"author": "TheBarthinator", "text": "Wow amazing how you made me understand graphs and I have extreme comfortability with the recursive approach and queue method. Always struggled understanding these implementations in python but as a web dev it made a lot more sense in JS. Thank you for taking the time to make this video!", "likes": 0}}, {"topLevelComment": {"author": "FJ", "text": "I wished your code was in JAVA", "likes": 1}}, {"topLevelComment": {"author": "Ams1 Ams", "text": "in the find minimum size island you can use grid.length * grid[0].length as initial min size island instead of infinity", "likes": 0}}, {"topLevelComment": {"author": "Paul Papacz", "text": "Amazing walkthroughs and explanations! Much appreciated \ud83d\ude4f", "likes": 0}}, {"topLevelComment": {"author": "Sid", "text": "Thank you for providing this course!!!", "likes": 0}}, {"topLevelComment": {"author": "Safi Abdul", "text": "number islands problem couldnt have been solved easier than this, kudos to this guy! for once i was able to understand the solution and complete the problem without errors.", "likes": 0}}, {"topLevelComment": {"author": "Mesghali Rasoul", "text": "Amazing, I love the way you explain graph algorithms", "likes": 0}}, {"topLevelComment": {"author": "aron canapa", "text": "I think this should be the first programming video anyone watches , I was struggling so hard before this", "likes": 0}}, {"topLevelComment": {"author": "J M", "text": "is breadthFirstPrint not suitable for a recursive version?", "likes": 0}}, {"topLevelComment": {"author": "Shuvo Habib", "text": "For colInbounds, the array should be grid[0] ?\nconst colInbounds = 0 <= c && c < grid[0].length;", "likes": 0}}, {"topLevelComment": {"author": "Alysha Gilliard", "text": "This was so gooooood!! Watching all the other ones. So glad I found this!", "likes": 0}}, {"topLevelComment": {"author": "Stargazing", "text": "Splendid! Alvin is an incredible instructor", "likes": 0}}, {"topLevelComment": {"author": "Casual Overwatcher", "text": "I haven't finished the video yet, but this will be very helpful  for my coding interviews!", "likes": 2}}, {"topLevelComment": {"author": "Amarjeet Chaurasia", "text": "Never looked graph so easy to me before I watched this one, thanks! \ud83d\ude0a", "likes": 5}}, {"topLevelComment": {"author": "Anupam Pandey", "text": "Hey Alvin, thanks, could you please create such videos on other topics like Heaps, Tries, Binary search trees etc.", "likes": 0}}, {"topLevelComment": {"author": "Australian Scholarships for International Students", "text": "great", "likes": 0}}, {"topLevelComment": {"author": "antoniorand", "text": "you might have solved my final project and thesis thank you", "likes": 0}}, {"topLevelComment": {"author": "NarengBull", "text": "Great video,", "likes": 0}}, {"topLevelComment": {"author": "Khai No", "text": "This instructor is great. I wish he create complete data structure and algo course.", "likes": 0}}, {"topLevelComment": {"author": "Navid M", "text": "Thanks!", "likes": 1}}, {"topLevelComment": {"author": "David S", "text": "wow, this person is an amazing teacher", "likes": 0}}, {"topLevelComment": {"author": "Madhubala Jayakumaran", "text": "Excellent course!", "likes": 0}}, {"topLevelComment": {"author": "Rudri", "text": "After @mycodeschool I found your channel, thank you for teaching the graph topic in such a simple manner.", "likes": 0}}, {"topLevelComment": {"author": "Sunil Jimenez", "text": "when do you compare the different distances between each found path ?", "likes": 0}}, {"topLevelComment": {"author": "Timothy L.J. Stewart", "text": "Hey Thanks @Alvin the Programmer, I have a question about the visited nodes @48:22, It appears you return to node K after marking it visited, and in the code @59:00 there doesn't appear to be a removed from visited call. I'm curious, how you are able to return to an already visited node such as @48:22? I'm thinking visited is a copy and each recursive call gets its unique state at the time of the call...", "likes": 0}}, {"topLevelComment": {"author": "Scrub", "text": "Wait, is this App Academy Alvin?!\n\nEdit: It just switched to PIP. It is! Alvin is the best?", "likes": 0}}, {"topLevelComment": {"author": "Maksatbek Burkanov", "text": "20:40 Looks like you need a queue to implement DFS, because stack is taking as current last node that  entered stack: \n[b, c] => current becomes \"c\" but you need \"b\", queue in this case fits this implementation", "likes": 0}, "replies": [{"author": "Maksatbek Burkanov", "text": "@Ayoub Alem thats right at beginning you append 2 nodes of F sequentially starting from right and lets say clockwise, then you will need to proceed with the first element that entered(because you need to go all the way deep with first element that you pushed not last)", "likes": 0}, {"author": "Ayoub Alem", "text": "Hi, if he used a queue he will end up with BFS traversal because he will print all the neighbours of each node before jumping to the children.\nBut for DFS traversal think of it like you append to the stack all the neighbours of a node once there is no more neighbours you pop the last neighbour you appended, and you start visiting its neighbours and so on.", "likes": 0}]}, {"topLevelComment": {"author": "Radhika Tupkary", "text": "This is phenomenal! I was finding Graph problems so difficult before watching this video, and now they seem fairly easy after watching the entire video! Thanks a ton!", "likes": 14}}, {"topLevelComment": {"author": "rjlacanlaled", "text": "why don't you use ++ instead of += 1", "likes": 0}}, {"topLevelComment": {"author": "Tetrax", "text": "Are there any tutorials that use the same hash map structure to build a graph with weights on it?", "likes": 0}}, {"topLevelComment": {"author": "Hor Meng Yoong", "text": "Great video and it is free. Thanks.\nBTW, what software was used to record the video and speaker head at the same time?", "likes": 0}}, {"topLevelComment": {"author": "Mazhar Ali", "text": "At 47:50 . Lets say we wanted to find 'm'. Since you marked 'K' as visited, and are now at 'l'. The icon shouldn't go back to 'K' (as it is visited), so does the program just ends there? Without finding a path to 'm', even though there is a path?", "likes": 0}}, {"topLevelComment": {"author": "thobias larsen", "text": "Thanks FreeCodeCamp and Alvin, you are doing some important work right here and contributing it to a large amount of people. I love you guys", "likes": 0}}, {"topLevelComment": {"author": "Prince Adigwe", "text": "How this person managed to explainamy concepts perfectly is superb... We really need people like this guy in the teaching field... I downloaded the video and I ve not regretted at all", "likes": 3}, "replies": [{"author": "Jimmy Bellmon", "text": "Me too I just realized Breathe First Traverse is Fibonacci", "likes": 0}]}, {"topLevelComment": {"author": "Samuel Okoth", "text": "Very good course. Thank you", "likes": 0}}, {"topLevelComment": {"author": "Julian Wareley", "text": "Nice one!", "likes": 0}}, {"topLevelComment": {"author": "Ifeanyi Okonkwo", "text": "Alvin and the chipmunks \ud83d\udc3f", "likes": 1}}, {"topLevelComment": {"author": "Rick", "text": "This was amazing. I've watched a bunch of these types of videos over the years and this is the only one that actually made it look easy. I can actually say I understand this now. Thank you.", "likes": 12}}, {"topLevelComment": {"author": "John Bell", "text": "For island count (1:58:20), you actually don't need a visited set to keep track of the tiles you have already visited. Simply set the land tile to water \"W\" when you visit it; you already have the logic there to skip over water tiles.", "likes": 8}, "replies": [{"author": "Manu mathew", "text": "If space complexity needs to be minimized and the interviewer allows in-place modification, then this is a good approach.", "likes": 0}, {"author": "Damian", "text": "Yes, but in real life, functions don\u2019t modify input objects, it\u2019s a bad practice. In an interview I wouldn\u2019t do it without asking.", "likes": 2}]}, {"topLevelComment": {"author": "Monotoba", "text": "just one quick clarification. At about 34 minutes in you say that n-squared is the number of edges in a graph. I think you mean that n-squared is the maximum number of edges in a graph. Your own diagram only shows 6 edges for a 3 node graph proving that n-squared is not always the number of edges in a graph. Also, the maximum number of edges will depend on the type of graph.", "likes": 0}}, {"topLevelComment": {"author": "Pianochess 1", "text": "1:40:45 wouldnt the convention be (4,3), i.e. (x,y) ?", "likes": 0}}, {"topLevelComment": {"author": "ChiefSittingStill", "text": "Excellent overall but one minor quibble: I hit a problem with Island Count in C++. If like me you're not particularly au fait with mathematical notation, you may go astray here too.\n\nThe C++ code on the website for the explore helper function uses what I believe it be a representation of the mathematical 'less than or equal to' symbol. It's not valid C++ (to my knowledge) and I can't even recreate it on my keyboard! I (incorrectly) took it to mean the C++ 'less than' symbol; this isn't correct, but it's not a glaringly obvious mistake - if you put that in and use Alvin's test cases, that error only manifests itself in the results of test_01 (I got 3 islands returned, not 4 as expected).\n\nTo make it clear for anyone else who makes the same mistake I did, I went with these as the first lines of code in my explore function (which is basically otherwise identical to Alvin's):\n\nconst unsigned int ZERO{0};\nbool rowInbounds = (ZERO <= row) && (row < grid.size());\nbool columnInbounds = (ZERO <= column) && (column < grid[ZERO].size());\n\nThis works fine.", "likes": 0}}, {"topLevelComment": {"author": "Johnson Tian", "text": "Thank you Alvin! Your explanation is GOLD!!! It's such a phenomenal tutorial that I find myself learning so much more efficiently!", "likes": 1}}, {"topLevelComment": {"author": "Manuel Jos\u00e9 Garc\u00eda Rodr\u00edguez", "text": "very well explained!! excellente!!", "likes": 0}}, {"topLevelComment": {"author": "Ramesh Reddy", "text": "Nice course. I wish it included topological stuff too.", "likes": 1}}, {"topLevelComment": {"author": "yadiki shameer", "text": "This guy literally changed the way I look at dynamic programming.", "likes": 3}}, {"topLevelComment": {"author": "Santosh Vaza", "text": "Awesome, thank you", "likes": 0}}, {"topLevelComment": {"author": "Dan Levy", "text": "Incredible!! thank you so much", "likes": 0}}, {"topLevelComment": {"author": "Harry Zachariou", "text": "Great video! At 1:00:00 isn't there a slight optimisation where you add the src to visited, as it will add it twice as it goes back up the stack so could wrap in a conditional to only add to visited if it doesn't already exist in visited?", "likes": 2}}, {"topLevelComment": {"author": "x", "text": "0:00 my expression whenever someone used to talk to me about graph algorithms before this video.", "likes": 0}}, {"topLevelComment": {"author": "sachin sasi", "text": "Abdf or ace .1 should follow  or 2 can be also followed", "likes": 0}}, {"topLevelComment": {"author": "VIKAS ER", "text": "Best video on Graphs.", "likes": 0}}, {"topLevelComment": {"author": "Shir Ganot", "text": "Why the islands problems are considered graph problems? Also, great video:)", "likes": 0}}, {"topLevelComment": {"author": "\u9673\u51a0\u5ef7", "text": "Thank you, Alvin.\nYour explanation is very clear and easy to understand!", "likes": 0}}, {"topLevelComment": {"author": "Kayla M", "text": "Thank you !", "likes": 0}}, {"topLevelComment": {"author": "d papa", "text": "excellent - thanks", "likes": 0}}, {"topLevelComment": {"author": "rajasaurus", "text": "nice, right, cool, awesome!", "likes": 0}}, {"topLevelComment": {"author": "Wesley", "text": "In the future would you mind please not talking with so much vocal fry (or stop chain smoking, whatever the case may be). It would provide a way better listening experience. thanks.", "likes": 0}}, {"topLevelComment": {"author": "velie a", "text": "time complexity of shortest path problem, starting at [1.24.03]. Why is linear complexity? We have a while loop and inside we have for loop. Is not it supposed to be (N square)", "likes": 0}}, {"topLevelComment": {"author": "Oscar Molina", "text": "Hey Alvin, I've observed in the minimum island count problem (2:10:00) is that you initialize minSize = infinity. I believe the worst case here is that the entire grid is an island, therefore you could've simply initialize minSize = len(grid) * len(grid[0]) (in Python code). Other than that, great recursive solution!", "likes": 0}}, {"topLevelComment": {"author": "Oscar Molina", "text": "Great video, thanks for sharing! In the island count problem (1:58:40) did you miss the grid[0].length upper limit for the column bound? If so, I'm not sure how your solution still works! I solved this problem using a slightly different approach, more related to my background in numerical simulations, which was first to convert the grid into a directed graph and then perform a breadth-first search at every node that hasn't been visited yet. Also, my solution seems to run a bit faster (~50 ms). \n\nHere's is my (more complex!) solution (in Python):\n\ndef island_count(grid):\n  graph, nodes = gridToGraph(grid)\n  count = 0\n  visited = set()\n  for i in nodes:\n    if (i not in visited):\n      if (bfs(graph, nodes, i, visited) == True):\n        count += 1\n  return count\n\ndef gridToGraph(grid):\n  nx = len(grid[0])\n  ny = len(grid)\n  size = nx * ny\n  \n  nodes = {}  \n  graph = {}\n  \n  for m in range(size):\n    i = m % nx\n    j = int(m / nx) % (nx * ny)\n    \n    nodes[m] = grid[j][i]\n    \n    left = None\n    right = None\n    up = None\n    down = None\n    \n    if (i > 0):\n      left = [m - 1, grid[j][i - 1]]\n    if (i < nx - 1):\n      right = [m + 1, grid[j][i + 1]]\n    if (j > 0):\n      up = [m - nx, grid[j - 1][i]]\n    if (j < ny - 1):\n      down = [m + nx, grid[j + 1][i]]\n        \n    if (m not in graph.keys()):\n      graph[m] = []\n    if (left != None):\n      graph[m].append(m - 1)\n    if (right != None):\n      graph[m].append(m + 1)\n    if (up != None):\n      graph[m].append(m - nx)\n    if (down != None):\n      graph[m].append(m + nx)\n    \n  return graph, nodes\n\ndef bfs(graph, nodes, n, visited):\n  if (n not in visited): visited.add(n)\n  if (nodes[n] == 'W'): return False\n  q = [n]\n  while (len(q) > 0):\n    i = q.pop()\n    for e in graph[i]:\n      if (e not in visited and nodes[e] == 'L'):\n        visited.add(e)\n        q.append(e)\n  return True", "likes": 2}}, {"topLevelComment": {"author": "rahul", "text": "watched your lecture on Dynamic Programming and now I am here. You are such a phenomenal teacher, thanks a ton for making these tutorials!", "likes": 4}, "replies": [{"author": "patrick udochukwu", "text": "Please @rahul what's the DP link", "likes": 0}]}, {"topLevelComment": {"author": "Zeryab Alam", "text": "This course is exceptionally well done. Completely understood the theory and implementation behind them damned graphs.", "likes": 14}}, {"topLevelComment": {"author": "Saptarshi Ghosh", "text": "@39:26 , you don't have to wait until the current == dest, an optimal approach is to maintain a visited set and add element to it when a un-visited neighbour is found. check if dest in the visited set or not, if yes then break the loop and return a True. The logic behind here, if you have seen your dest already you don't have to wait until it pops out. This won't change the asymptotic upper-bound but optimises the average case runtime with early stopping. N.B. same logic is applicable for iterative and recursive DFS.", "likes": 0}}, {"topLevelComment": {"author": "WEN LIN", "text": "Why is number of edges n^2? It looks like it's just 2n, maybe an edge to the node itself count as one edge too?", "likes": 0}}, {"topLevelComment": {"author": "undefined undefined", "text": "Love your explanation , you are the best ! Thanks for the course!", "likes": 0}}, {"topLevelComment": {"author": "P Z", "text": "Just finished the Dynamic Programming from Alvin and now back at the Graph algorithm. ", "likes": 2}}, {"topLevelComment": {"author": "Eternal Wanderer", "text": "Thank you so much. This is the only video on YouTube which addresses the graph algorithms the way they should be addressed - graphical visualization, pseudocode and actual problem solving.", "likes": 0}}, {"topLevelComment": {"author": "Gustavo Lopes", "text": "Amazing video! Thanks Alvin <3", "likes": 0}}, {"topLevelComment": {"author": "Monika Jha", "text": "Alvin, you literally took away my fear of Graph DS. Cannot thank you enough.", "likes": 0}}, {"topLevelComment": {"author": "Fine Mouche", "text": "34:31 : you mean 2n, no ?", "likes": 0}}, {"topLevelComment": {"author": "Fine Mouche", "text": "32:20 ; for f to j (the reverse) it's easy to answer : j is in dependency of 0 letters / j is not in a dependency of a letter. so no path from all letters to j.", "likes": 0}}, {"topLevelComment": {"author": "Fine Mouche", "text": "24:55 for this graph i have infinite loop beetween e and f :\ndependency={'a':('b','e'), 'b':('a','c','d'), 'c':('b','e'), 'd':('b'), 'e':('a','c','f'), 'f':('e')} for the non recursvive algo and beetween a and b for the recursive one.\n(i see an undirected graph section, will see if it answer my issue)", "likes": 0}}, {"topLevelComment": {"author": "Vibhusha Jain", "text": "Thank you for making graphs so easy for me! Appreciate your patience to make these videos and share", "likes": 2}}, {"topLevelComment": {"author": "Samuel Wahlberg", "text": "Great teacher!", "likes": 0}}, {"topLevelComment": {"author": "toordog", "text": "This is a decent tutorial,  but the approach to edges and graph data is extremely fragmented. This clearly needs a pre train to make this more effective and efficient.", "likes": 0}}, {"topLevelComment": {"author": "Doug", "text": "This is awesome! I've been struggling with graphs until I saw this video, great course.", "likes": 0}}, {"topLevelComment": {"author": "Fine Mouche", "text": ".push = .append/.add in python but what could be .shift ?", "likes": 0}, "replies": [{"author": "Fine Mouche", "text": "ok it's pop(0) / popleft()", "likes": 0}]}, {"topLevelComment": {"author": "0ffset92", "text": "A true master, living legend. thank you so much", "likes": 0}}, {"topLevelComment": {"author": "Pranav Kumar", "text": "Thanks!", "likes": 0}}, {"topLevelComment": {"author": "Leo John", "text": "Hello. I was wondering why you don't use the visited array or map to denote the visited node? Because it may have a cycle in the graph.", "likes": 0}}, {"topLevelComment": {"author": "Kaiser Konok", "text": "Best course for learning graph algorithm\ud83d\udd25\ud83d\udd25", "likes": 0}}, {"topLevelComment": {"author": "gustav gans", "text": "Hey, CSauce! Michael here", "likes": 0}}, {"topLevelComment": {"author": "Shrikant Chaudhari", "text": "shouldn't be a number of edges in the directed graph equal to \"n(n-1)\"? instead of n^2? @Alvin the Programmer", "likes": 1}}, {"topLevelComment": {"author": "CDMusicGroup", "text": "\u201cLater on in the tutorial we\u2019ll go over examples of when u might use one over the other\u201d\n\nWhat a breath of fresh air \ud83d\ude4f\ud83c\udffc", "likes": 0}}, {"topLevelComment": {"author": "Mandi Haase", "text": "All of Alvin's content is amazing! I signed up for Structy after doing this course and the course on trees, and love it!", "likes": 1}}, {"topLevelComment": {"author": "sulabh bajaj", "text": "This guy is amazing..", "likes": 0}}, {"topLevelComment": {"author": "lulusaikou", "text": "Wonderful video!!! I am familiar with graph now, thank you Alvin\ud83d\udc95 I will follow your next video and looking forward to your more courses. Thanks fcc too.\u2764", "likes": 0}}, {"topLevelComment": {"author": "Santhosh Sankar", "text": "Just a excellent explanation. After some point i started solving the problem before looking into your explanation.", "likes": 0}}, {"topLevelComment": {"author": "Sakithya Gopinath", "text": "This is the best! Thank you for doing this :)", "likes": 0}}, {"topLevelComment": {"author": "Gunratna More", "text": "Helpful enough \ud83d\udc4d", "likes": 0}}, {"topLevelComment": {"author": "Anil Chaudhary", "text": "very clear and precise", "likes": 0}}, {"topLevelComment": {"author": "tybaltmercutio", "text": "Overall quite nice.\nBut in my opinion the explanation of the the relationship between the number of number of nodes and the number of edges was pretty bad.\nIt was totally unclear from the example why the number of edges should be O(n^2) since 3^2 != 6, where n = Number of nodes.\n\nIt would have been better to say that that the in the worst case scenario the number of edges can be obtained from the number of nodes n by n^2 - n. Then, in big O notation only the dominant terms survive, i.e. the n^2 term.", "likes": 0}}, {"topLevelComment": {"author": "Aakash Goyal", "text": "Very nice explanation. I hardly liked graphs before watching this video. Now they make a lot of sense to me and now I know how to at least proceed to solve a graph problem. Thanks for the great content.", "likes": 0}}, {"topLevelComment": {"author": "Terah Bruce", "text": "Alvin is the by far the best programming teacher on youtube imo", "likes": 0}}, {"topLevelComment": {"author": "doodeoo", "text": "Great video but you should stop saying \"..right?\" at the end of every other sentence", "likes": 0}}, {"topLevelComment": {"author": "Pranav Kumar", "text": "Wish Corona was only a depth first preferring virus :(", "likes": 0}}, {"topLevelComment": {"author": "Mohamed Saligh", "text": "Best explanation I ever watched in Youtube. You deserve a thumbs up and a comment from a laziest person on earth!", "likes": 1}}, {"topLevelComment": {"author": "PsychoCoder", "text": "i've only learned python, would you consider this to be a good introductory course that could teach me the basics of coding in javascript?", "likes": 0}, "replies": [{"author": "Code Cleric", "text": "Not really, as it's highly focused to just coding graphs. I'd recommend going through some exercises on FreeCodeCamp.org's JavaScript section on their website for a good overview. Also the channel Fun Fun Function is a great channel for learning good JavaScript practices.", "likes": 0}]}, {"topLevelComment": {"author": "Arslan Ahmed Qureshi", "text": "It was great course yo should hunt one for geometry one too. i will look forward towards that too happily", "likes": 0}}, {"topLevelComment": {"author": "Spring Dev", "text": "34:24 n= nodes n^2 = edges ...but in diagram there are 3 nodes and 6 edges which is clearly not 9 ..how is it possible ..can anyone explain please", "likes": 0}}, {"topLevelComment": {"author": "Mazen Khaled", "text": "The guy that's in the intro of every freeCodeCamp videos scares me idk", "likes": 0}}, {"topLevelComment": {"author": "Sukhwant Samra", "text": "video at round 34:40 you described if n nodes then there could be n*n edges, but should it be 2n?", "likes": 0}}, {"topLevelComment": {"author": "praveen rawat", "text": "wow your explanation is just amazing! Never thought it would so easy.", "likes": 0}}, {"topLevelComment": {"author": "Andy Miller", "text": "Repost, so I can like it again!", "likes": 0}}, {"topLevelComment": {"author": "Sean Nakasone", "text": "wow, you explain very well.  well done.", "likes": 0}}, {"topLevelComment": {"author": "Bhavyaa Sharma", "text": "Very nicely explained", "likes": 0}}, {"topLevelComment": {"author": "Alex", "text": ": 34:27 wouldn\u2019t number of edges be 2n (2 times n) instead of n^2 (worst case graph)?", "likes": 4}, "replies": [{"author": "smn", "text": "it's not the exact number of edges but complexity. The max number of edges can be n * (n - 1) ~ O(n^2)", "likes": 1}]}, {"topLevelComment": {"author": "Samuel Agyakwa", "text": "Wow, wow, wow. I've always struggled with graph algorithms and this video basically just taught me everything I need to know about them. I have an onsite with google soon and its safe to say if they ask any graph questions, even if it's not in this video, I'm going to crush it. I highly recommend this video to anyone who is unsure if they should spend the 2 hours watching. THANK YOU FOR THIS VIDEO!", "likes": 4}}, {"topLevelComment": {"author": "njgamez", "text": "One issue in the shortest path,  1:36:16  , its that whenever you find the destination you always return it. Its not always the shortest path. \nYou can maintain a min counter to maintain the shortest distance.\nAlso thanks for the wonderful video,  just by following the videos , I could do the implementation on my own", "likes": 0}, "replies": [{"author": "njgamez", "text": "@Siddhant Gupta correct,  thanks for the detailed explaination. I came to know about this after doing many bfs problems. I dont knw if it was mentioned in this video, if not then it should be mentioned :) happy coding", "likes": 1}, {"author": "Siddhant Gupta", "text": "I think that would have been an issue if we were using DFS, considering the nature of BFS and visited set that we are using, whenever we find the destination, that path will always be the shortest.", "likes": 1}]}, {"topLevelComment": {"author": "hpandeymail", "text": "Love the details author has shared .. thank you very much Sir \ud83d\ude4f\ud83d\ude4f", "likes": 0}}, {"topLevelComment": {"author": "Christopher Mitchell", "text": "100% the best teacher I've seen. You are legit the best, my dude.", "likes": 0}}, {"topLevelComment": {"author": "Jenkins J", "text": "when i implemented his breadth-first code, \n\nconst breadthFirstPrint = (graph, source) => {\n\u00a0 \u00a0 const queue = [source];\n\n\u00a0 \u00a0 while (queue.length > 0) {\n\u00a0 \u00a0 \u00a0 \u00a0 const current = queue.shift();\n\u00a0 \u00a0 \u00a0 \u00a0 console.log(current);\n\n\u00a0 \u00a0 \u00a0 \u00a0 for (let neighbour of graph[current]) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 queue.push(neighbour);\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 }\n};\n\n// javascript object with constant look-up\nconst graph = {\n\u00a0 \u00a0 a: ['b', 'c'],\n\u00a0 \u00a0 b: ['d'],\n\u00a0 \u00a0 c: ['e'],\n\u00a0 \u00a0 d: ['f'],\n\u00a0 \u00a0 e: [],\n\u00a0 \u00a0 f: []\n};\n\nconsole.log(breadthFirstPrint(graph, 'a')); // a, b, c, d, e, f\n\ni am getting an 'undefined' at the end. he is not getting that 'undefined'. can anybody clarify this???", "likes": 0}}, {"topLevelComment": {"author": "sukhoiskunk", "text": "nice.", "likes": 0}}, {"topLevelComment": {"author": "Vladimir Podesva", "text": "Hello, Thanks lot very helpful. For someone who is interested I have another solution for the before last example. It is to create a graph from the grid and use the graph to extract number of islands by using previous algorithms. Here is the code:\n\n    vector<vector<int>> islands = { {0,1,0,0,0,0,0,0,0,1},\r\n                                    {0,1,0,0,0,0,0,0,0,0},\r\n                                    {0,0,0,0,1,0,0,0,0,0},\r\n                                    {0,0,0,0,0,0,0,0,1,1},\r\n                                    {0,0,0,0,0,0,0,0,0,1},\r\n                                    {0,0,0,1,0,0,0,0,1,1} };\n\n//Counting islands of land\r\nstatic int CountIslands(const vector<vector<int>> &area)\r\n{\r\n   set<pair<int,int>> visited;\r\n   vector<pair<int,int>> points;\r\n   int unique = 0;\r\n\r\n   for(int row = 0; row < area.size(); ++row)\r\n   {\r\n       for(int col = 0; col < area.at(row).size(); ++col)\r\n       {\r\n          if(col < area.at(row).size() - 1)\r\n          {\r\n             if(((area[row][col] == 1) && (area[row][col + 1] == 1)))\r\n             {\r\n                points.push_back(make_pair(unique, unique + 1));\r\n             }\r\n          }\r\n\r\n          if(row < area.size() - 1)\r\n          {\r\n             if(((area[row][col] == 1) && (area[row + 1][col] == 1)))\r\n             {\r\n                points.push_back(make_pair(unique, unique + area.at(row).size()));\r\n             }\r\n          }\r\n\r\n          if( (area[row][col] == 1) && points.back().first != unique)\r\n          {\r\n              points.push_back(make_pair(unique, unique));\r\n          }\r\n           unique++;\r\n       }\r\n   }\r\n\r\n   return ConnectedComponents(BuildGraph(points));\r\n}", "likes": 0}}, {"topLevelComment": {"author": "Tugrul Pinar", "text": "Thanks a lot Alvin! This is awesome", "likes": 0}}, {"topLevelComment": {"author": "kovardhan rajesh", "text": "1:57:59,the varaible \"visited\" ain't mentioned global anywhere but still it gets updated after it gets into the function, can amyone explain this one...", "likes": 0}, "replies": [{"author": "kovardhan rajesh", "text": "@Alvin the Programmer understood\nAwesome work bro \ud83d\ude31", "likes": 1}, {"author": "Alvin the Programmer", "text": "Hey! In JavaScript, non-primitive types (types that are not simple boolean, number, string, etc..) behave \"as pass by reference\". This means if we mutate a non-primitive argument like a visited Set, the mutation persists even after the function returns. In other words, when we pass the set as an argument, we are passing the actual set in memory, we are not passing a \"copy\" of the set.\n\nHope that clarifies!\nAlvin", "likes": 0}]}, {"topLevelComment": {"author": "Gusto", "text": "Thanks a lot!", "likes": 0}}, {"topLevelComment": {"author": "Jamandiin Savkhlan", "text": "D enters through the back and behind C. Hmmmmmm", "likes": 1}}, {"topLevelComment": {"author": "Vinay KR", "text": "My question regarding shortest path problem.\nAssume there are multiple paths from src to dest. how are you ensuring that the minimum path is picked ? since we are not storing the minimu path. we are returning the distance as soon as curr and dest match. What if we find the longer path earlier than the shorter path.", "likes": 0}, "replies": [{"author": "Where", "text": "Because we're using Breadth First Search instead of Depth First Search. Breath First Search is an algorithm that visits all the children nodes one by one before going deeper in the graph so that means the first path we find using BFS is the shortest path.", "likes": 0}]}, {"topLevelComment": {"author": "Tytus Gierycz", "text": "I'm grateful for this wonderful material it's so smooth and fine great for my algorithm edge grinding :)", "likes": 0}}, {"topLevelComment": {"author": "Evie Uyen Ta", "text": "by far the best tutorial!!! i finally am getting better at this. THANKS A TON!", "likes": 0}}, {"topLevelComment": {"author": "Derek Williams", "text": "This guy teaches so well I thought I was learning how to make a sandwich!", "likes": 3}}, {"topLevelComment": {"author": "Ranjan Venkatesh", "text": "Thanks", "likes": 0}}, {"topLevelComment": {"author": "B\u00fc\u015fra Tun\u00e7dan", "text": "What a clear explanation. Thanks a lot!", "likes": 0}}, {"topLevelComment": {"author": "TickkuN", "text": "\u3081\u3061\u3083\u304f\u3061\u3083\u5206\u304b\u308a\u3084\u3059\u304b\u3063\u305f!!\nAlvin\u3055\u3093\u3042\u308a\u304c\u3068\u3046!!", "likes": 0}}, {"topLevelComment": {"author": "gardening 0712", "text": "amazing video!", "likes": 0}}, {"topLevelComment": {"author": "Night Fury", "text": "I feel my brain expanding", "likes": 1}}, {"topLevelComment": {"author": "Matt Skelton", "text": "Totes profesh.", "likes": 0}}, {"topLevelComment": {"author": "Yuna F", "text": "By far the best video that I have ever seen on this topic, thank you for all the effort you put into this Alvin!", "likes": 0}}, {"topLevelComment": {"author": "Locdness Momster", "text": "In the future, please please please don't go for such a bright background.", "likes": 0}}, {"topLevelComment": {"author": "instagib783", "text": "Yooo, I just realized that this is how AI pathfinding works in video games. Neat.", "likes": 0}}, {"topLevelComment": {"author": "Israel McCulley", "text": "Excellent presentaion! The visuals and code are explained very clearly, very easy to follow", "likes": 0}}, {"topLevelComment": {"author": "Ashish Kumar", "text": "Easy Java Solution: \r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\n\r\npublic class Graph {\r\n    \r\n    public static HashMap<Integer, List<Integer>> edgeArrayToAdjacencyList(int [][] edges){\r\n\r\n        HashMap<Integer, List<Integer>> adjacencyList = new HashMap<>();\r\n        if(edges.length == 0) return adjacencyList;\r\n\r\n        for(int edge[] : edges){\r\n            int v1 = edge[0];\r\n            int v2 = edge[1];\r\n            List<Integer> adj = new ArrayList<>();\r\n            if(!adjacencyList.containsKey(v1)){\r\n                adj.add(v2);\r\n                adjacencyList.put(v1, adj);\r\n            }\r\n            else adjacencyList.get(v1).add(v2);\r\n            adj.clear();\r\n            if(!adjacencyList.containsKey(v2)){\r\n                adj.add(v1);\r\n                adjacencyList.put(v2, adj);\r\n            }\r\n            else adjacencyList.get(v2).add(v1);\r\n        }\r\n        return adjacencyList;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        int edges[][] = {{0,0}};\r\n        System.out.println(\" Adjacency List : \"+edgeArrayToAdjacencyList(edges));\r\n\r\n    }\r\n}", "likes": 0}}, {"topLevelComment": {"author": "Dibin Nadar", "text": "Tries to like the video twice...", "likes": 0}}, {"topLevelComment": {"author": "Govinda Pandey", "text": "Amazing", "likes": 0}}, {"topLevelComment": {"author": "KALI BENYBEN", "text": "It's confusing when the object contains the same keys as values, but it still a good course, thank you", "likes": 0}}, {"topLevelComment": {"author": "Douglas Chiang", "text": "Can someone further explain to me why we can say the time complexity of BFS/DFS can be O(n^2), the worst case presented in the video which had 3 nodes and 6 edges is not quite clear to me. Shouldn't n^2 = 3^2 = 9?", "likes": 1}, "replies": [{"author": "Khalil Ben Safta", "text": "Am reading in another comment that the number of edges in an n-nodes complete (complete means here alla nodes connected to all nodes) graph is n(n-1) (which make sense, since each node has to connect to the n-1 remaining nodes) and confirms the 6 edges for 3-nodes graph example in the video", "likes": 0}, {"author": "Khalil Ben Safta", "text": "Same question for me", "likes": 0}]}, {"topLevelComment": {"author": "Camilo Salazar", "text": "Question how do you convert an edge list to an adjacency list  when the sub array can be any size nth length?  when you have something like this case:\nedge = [\n[1,2],\n[2,3,4],\n[3,5],\n[]\n]?\nLove your videos man!", "likes": 0}, "replies": [{"author": "ABHIRUP DAS", "text": "graph={ }\nfor i,neighbourhood in ennumerate(edge):\n     graph[i]=[ ]\n     graph[i].extend(neighbourhood)\n\n#This is the required code...provided that in the edge list the index corresponds to the node and all the other nodes in list are its neighbours.\n\n\ngraph={ }\nfor edgelist in edge:\n     if(len(edgelist)>0):\n        graph[edgelist[0]]=[ ]\n        for edges in range(1,len(edgelist)):\n             graph[edgelist[0]].append(edges)\n\n#This is the code if each of the first element ofsublist corresponds to the node and other elements corresponds to its neighbour...which is the case in most of the questions.", "likes": 0}]}, {"topLevelComment": {"author": "Madhukiran Attivilli", "text": "@1:49:00 -- Island Count problem -- Instead of adding [row, col] to visited set, change grid[row][col] value from 'L' (for land) to 'V' (for visited). Helps to avoid an additional Set DS!", "likes": 1}}, {"topLevelComment": {"author": "aayush samant", "text": "can anyone tell me how that space complexity is \"n Square\" as it says no. of edges.", "likes": 0}}, {"topLevelComment": {"author": "Madhukiran Attivilli", "text": "@5:45 : How can u say that a map provides constant time lookup?\n\nMap is a hashtable. Doesn't matter how efficient is the hash function, how efficient is the probing function to resolve collision, how perfect is the prime number used as hash table size, etc, a hashtable can provide constant time lookup only when there is no collision\n\nConstant time lookup by avoiding collision, and very quick lookup after a collision using the probing function -- both depend on the load factor. The smaller the load factor (like 0.4 or 0.3) the better probability to get constant time lookup\n\nBut such low load factor requires very frequent resizing which takes linear time O(n) (n: HT size)\n\nSo, it is safe to say that except an array nothing can guarantee a constant time lookup\n\nAn adjacency list can be represented as an array of arrays. Since most of the graph problems uses static graphs (i.e. graphs doesn't dynamically change), array sizes are known at the beginning itself.\n\nOuter array size: |V|\nEach inner array size: |Ev| (Ev: # of outgoing edges of node v)\n\nWe need a map only to maintain a relation between the node names (either strings or literals) and node indices (indices of outer array).\n\nPlease comment/correct.", "likes": 0}}, {"topLevelComment": {"author": "Chimera Black", "text": "I don't understand big O.  It seems to have no rhyme or reason to me. People just randomly say things declaratively and never explain where it comes from.", "likes": 0}}, {"topLevelComment": {"author": "Angel Sanchez", "text": "Thank you Alvin!", "likes": 0}}, {"topLevelComment": {"author": "Benhard Sim", "text": "MY GOD this is really good thank you soon much", "likes": 0}}, {"topLevelComment": {"author": "Gevorg Galstyan", "text": "Hey Alvin. Thank you for this wonderful video. I have recently purchased subscription on structy.net and I would like to thank you for such amazing product. It is definitely the best platform to learn core principles of DS&A. There are currently 100 questions on platform and I am wondering if you planing to add additional problems???", "likes": 0}}, {"topLevelComment": {"author": "Bart Zumba", "text": "why talk so fast like you are trying to get this done asap.. but appreciate the effort since its free just kinda hard to follow and slowing down sounds like robot", "likes": 0}}, {"topLevelComment": {"author": "just for fun", "text": "why this amazing course is not in cpp.", "likes": 1}}, {"topLevelComment": {"author": "Rob Rosario", "text": "Thanks!", "likes": 0}}, {"topLevelComment": {"author": "Fadi Hanna Al-Kass", "text": "This was a nice refresher since my college days", "likes": 0}}, {"topLevelComment": {"author": "Unknown User", "text": "this class is only confusing people. does not really help", "likes": 0}}, {"topLevelComment": {"author": "Aastha Aggarwal", "text": "really learnt a lot ..thanks ..keep making such mesmerizing content", "likes": 0}}, {"topLevelComment": {"author": "Matthew Cochrane", "text": "Is Casually Explained your alt channel?  Your voice sounds so similar \ud83e\udd23", "likes": 0}}, {"topLevelComment": {"author": "Aman", "text": "He makes it look so easy, wish I had jumped across these tutorials earlier. But will use them now.", "likes": 0}}, {"topLevelComment": {"author": "Kanak Mittal", "text": "Man! you have my respect. This was the best course for getting started with graph problems I have ever seen. Thank You so much.", "likes": 25}}, {"topLevelComment": {"author": "Bin Wang", "text": "The reason that DFS has a recursive implementation while BFS doesn't is because recursive is basically taking advantage of the call/frame stack implicitly (LIFO), no luck for BFS.", "likes": 1}, "replies": [{"author": "Bin Wang", "text": "@Carlo Bagnoli indeed. indeed", "likes": 0}, {"author": "Carlo Bagnoli", "text": "That's a partial lie, it doesn't have a recursive implementation if you follow the exact path he took, but the recursive BFS is actually really simple.\nconst BFS = (graph, source) => source.length && BFS(graph, [...graph[source.pop()], ...source])\nAnd hence you just do: BFS(graph, ['a'])", "likes": 0}]}, {"topLevelComment": {"author": "kelvin muza", "text": "My guy, I don't know how to thank you. You have a marvelous way of teaching. This has really helped me a lot", "likes": 3}}, {"topLevelComment": {"author": "Shy Guy Mercedes Benz", "text": "You did a great job covering this material.\nBut is this really all it is?\nThere's gotta be more, right?\nIt's the same thing every time... Usually a DFS, sometimes a BFS. Nothing else.\nIs that really all a graph question will ever be?\nAt Google or Facebook, etc?", "likes": 1}}, {"topLevelComment": {"author": "Novum", "text": "How is it possible to solve shortest path using DFS, since DFS does not guarantee that nodes it encounters first are closer than nodes it encounters later?", "likes": 0}}, {"topLevelComment": {"author": "Eidmone", "text": "Better than watching a movie<3", "likes": 0}}, {"topLevelComment": {"author": "akhil chandra", "text": "Thanks!", "likes": 0}}, {"topLevelComment": {"author": "entcune", "text": "You made such high level topic like a walk in park thanks alot man. Waiting for more such videos from you.", "likes": 0}}, {"topLevelComment": {"author": "Vinayak Tyagi", "text": "Can you please make a video on Greedy Algorithm ?", "likes": 0}}, {"topLevelComment": {"author": "White Bear", "text": "Awesome", "likes": 0}}, {"topLevelComment": {"author": "Emmanuel Wada", "text": "Wow, this is such a huge help !", "likes": 0}}, {"topLevelComment": {"author": "Ahmed Mohiy", "text": "first thanks for this video, Second in the last two examples u wrote in the for loop grid[0].length i think it should be grid[r].length cause if the grid is not squared if not pls explain thanks so much", "likes": 0}}, {"topLevelComment": {"author": "The Punisher", "text": "Just for correction, Islands count problem, inside DFS function for checking boundaries, for 'j' check for j < grid[0].length, because if in NxM grid N !== M, in that case j < grid.length cannot check for true boundary and result will be wrong, I just wanna mention that in case", "likes": 0}}, {"topLevelComment": {"author": "PHILLBERT PHINTO (RA1811003020550)", "text": "Thanks for this video man!!", "likes": 0}}, {"topLevelComment": {"author": "Kaspar", "text": "8:50 you mean for the first two iterations of the algorithm, not three, right?", "likes": 0}}, {"topLevelComment": {"author": "Mishkat Hossain", "text": "We want more tutorial of Alvin. \nThis guy kills it!!!", "likes": 0}}, {"topLevelComment": {"author": "Alan Almeida", "text": "Was the algorithm we used for shortest path Djisktra's algo?", "likes": 1}}, {"topLevelComment": {"author": "Alan Almeida", "text": "Thanks a lot! just finished the first section (dfs and bfs) and it got soldered into my brain! well taught!", "likes": 1}}, {"topLevelComment": {"author": "simsim", "text": "Can anyone explain me how does this recursion call is adding 1 to size? (minimum island)\n size = 1\r\n size += explore_size(grid, r - 1, c, visited)", "likes": 0}, "replies": [{"author": "Keerthi", "text": "It is weekend, go get some sleep", "likes": 0}]}, {"topLevelComment": {"author": "Alessio Celentano", "text": "I never comment on YouTube, but I love the way Alvin explains concepts. Thanks a lot for your work!", "likes": 4}}, {"topLevelComment": {"author": "Ram Chhabra", "text": "1:39:32", "likes": 0}}, {"topLevelComment": {"author": "Senthil Kumar", "text": "Good Job . well done .  Keep it up !!!!", "likes": 0}}, {"topLevelComment": {"author": "Xu XinXu", "text": "I knew it was gonna be good before I watched it, the DP course was phenomenal.", "likes": 1}}, {"topLevelComment": {"author": "Shailendra Maurya", "text": "Thanks!", "likes": 0}}, {"topLevelComment": {"author": "Eyal Pery", "text": "This content is pure gold", "likes": 0}}, {"topLevelComment": {"author": "Yichi Zhang", "text": "For island count, shouldn't the guard be:\n    const rowinbounds = 0 <= r && r < grid.length;\r\n    const columnInbounds = 0 <= c && c < grid[0].length;\n\nsince the island could be bigger on the side.\n\n1:58:37", "likes": 0}}, {"topLevelComment": {"author": "benjamin peterson", "text": "Alvin sensei sugoi", "likes": 0}}, {"topLevelComment": {"author": "Sede", "text": "This course is hands-down, unequivocally fantastic!!! Best useful course I've seen about graphs. It ties together the algorithms with concrete use cases which just clicked. Thank you for the fantastic job!!!!", "likes": 6}}, {"topLevelComment": {"author": "Pratibha Gupta", "text": "Alvin, your way of explaining stuff is just amazing. I never understood graphs and recursion so well before that. I have found your DP tutorial too, that is also wonderful. If you can provide links to your other tutorials of algorithms, that will be great.\n\nAlso, I am struggling a little bit to understand to get all the possible paths from a source to destination. I have followed other tutorials as well, but I wish you would have covered this too.", "likes": 6}, "replies": [{"author": "Alvin the Programmer", "text": "Glad to hear you found value in my content! If you'd like to check out more of my data structure and algorithm work, you'll want to check out my platform, Structy (link in the video description). There I cover all data structures with plenty of free problems to check out!\n\nBest,\nAlvin", "likes": 1}]}, {"topLevelComment": {"author": "Data Str and Algo", "text": "I want to like this video 100 more times. I could like it only one time.", "likes": 0}}, {"topLevelComment": {"author": "Naman Jain", "text": "Sadly this cannot be followed in c++ I tried and failed to create even a map cuz array cannot be taken as value in map someone helpppp", "likes": 0}, "replies": [{"author": "Alvin the Programmer", "text": "@Naman Jain Cheers :)", "likes": 1}, {"author": "Naman Jain", "text": "@Alvin the Programmer omg that clears a lot of stuff again thank you so much finally I can continue the lesson! My Hero!!", "likes": 0}, {"author": "Alvin the Programmer", "text": "@Naman Jain Say we had an unordered map initialized as this:\n\n std::unordered_map<std::string, std::vector<std::string>> graph {\n  { \"f\", {\"g\", \"i\"} },\n  { \"g\", {\"h\"} },\n  { \"h\", {} },\n  { \"i\", {\"g\", \"k\"} },\n  { \"j\", {\"i\"} },\n  { \"k\", {} }\n };\n\nUnordered_maps represent a key,value pair of data. Using the template type <std::string, std::vector<std::string>> , we are saying that the keys are strings and the values are vectors of strings. Looking at the first entry of the map, { \"f\", {\"g\", \"i\"} },  it means that \"f\" is a key and its corresponding value is the vector of {\"g\", \"i\"}. In the context of our graph it means that node \"f\" has an edge pointing to \"g\" and an edge pointing to \"i\".\n\nHope that helps!\n\n\n-AZ", "likes": 1}, {"author": "Naman Jain", "text": "@Alvin the Programmer still can you explain what is the logic here? sorry I'm just a beginner and thanks again.", "likes": 0}, {"author": "Naman Jain", "text": "@Alvin the Programmer thank you so much you are the best!", "likes": 0}]}, {"topLevelComment": {"author": "Naman Jain", "text": "When we made dictionary, actually in c++ there are maps so I don't know how to make array of characters as a value in maps can anybody help?", "likes": 0}}, {"topLevelComment": {"author": "snehalkumar.singh.cse20", "text": "while writing an arrow function, we often end up typing + than =, such a common problem!!", "likes": 0}}, {"topLevelComment": {"author": "dArShAN rOck", "text": "How did we arrive to decision that we need to use graph for that matrix island question, we could learn the algorithms but where to apply and how to get to know  that this algorithm fits this problem is important.  may be there could be  another ways to solve the same problem. hmmm its very confusing.  somehow the approach you're teaching us is great.", "likes": 0}}, {"topLevelComment": {"author": "dante dt", "text": "Best!", "likes": 0}}, {"topLevelComment": {"author": "Dragan Ostojic", "text": "Instead of stringifying pair [r, c] it could be converted into an integer uniquely as follows: r * col_length + c.", "likes": 1}}, {"topLevelComment": {"author": "Dragan Ostojic", "text": "In the inner loop of grid traversal, it would be more general to use for (let c = 0; c < grid[r].length; c += 1) This will take care of different row lengths.", "likes": 1}, "replies": [{"author": "Yichi Zhang", "text": "Agreed!", "likes": 0}]}, {"topLevelComment": {"author": "Annant Sharma", "text": "Thanks for the video. To be honest, this is one of the best graph tutorials I have ever witnessed. My core concepts and understanding towards this Data Structure has improved and I really appreciate the efforts you have put in to make this video.\ud83d\ude4f", "likes": 1}}, {"topLevelComment": {"author": "RodneyTV", "text": "Phenomenal! I wish you were my prof in Uni \ud83d\ude2d", "likes": 5}}, {"topLevelComment": {"author": "Svetlana Parvathi", "text": "God bless you! Eternal blessings \ud83d\ude4f\ud83d\udc9e", "likes": 0}}, {"topLevelComment": {"author": "Ajinkya Meshram", "text": "I love his smooth voice", "likes": 0}}, {"topLevelComment": {"author": "Marland Kennedy", "text": "I wish you where teaching this when I took this class.", "likes": 0}}, {"topLevelComment": {"author": "Bhargav Pandya", "text": "I just cannot believe how good this explanation was! Thanks Alvin!!", "likes": 1}}, {"topLevelComment": {"author": "Sri", "text": "In a directed graph, how to count the number of cycles ? what approach to follow ??", "likes": 0}}, {"topLevelComment": {"author": "Sri", "text": "In a graph how to count the number of cycles ?", "likes": 0}}, {"topLevelComment": {"author": "Joan N", "text": "Is the connected components part the same as union find?", "likes": 0}}, {"topLevelComment": {"author": "Robin", "text": "Your course on DP helped me big time.", "likes": 0}}, {"topLevelComment": {"author": "OLIWEB", "text": "I'd always been scared of learning graphs, even though I wanted to... but this course took my fear away \ud83d\ude0e\ud83d\udc4d\ud83c\udffb excelente course, as always!", "likes": 67}}, {"topLevelComment": {"author": "DI NERO-COSTA", "text": "This was probably the most useful tutorial I've seen on YT. Great work!", "likes": 1}}, {"topLevelComment": {"author": "yilmaz bingol", "text": "is this guy something, or is he something :)", "likes": 0}}, {"topLevelComment": {"author": "DHANESH S", "text": "Do full course on tree data structures \ud83d\ude4f\ud83d\ude4f\nThese complete courses are so impressive", "likes": 0}}, {"topLevelComment": {"author": "gooash", "text": "This is a very outstanding course. Thanks", "likes": 0}}, {"topLevelComment": {"author": "Amarnath Prasad", "text": "This was a really good video. Thank you Alvin and FCC.", "likes": 1}}, {"topLevelComment": {"author": "Thee Greatest Ever", "text": "Have yet to work on this but want to express my gratitude and wish you greatness in all aspects of your life!", "likes": 0}}, {"topLevelComment": {"author": "Chandradhar Rao", "text": "First dp and now graph!Thas so kind!Thanks!", "likes": 0}}, {"topLevelComment": {"author": "algoRanger", "text": "I saw the video and rushed to like it...without the need to see the video and then feel oh its good and then be like lets click on the like button..", "likes": 0}}, {"topLevelComment": {"author": "karthik K", "text": "Awesome course and great explanation\u2728Thanks a lot alwin and  freecodecamp team", "likes": 0}}, {"topLevelComment": {"author": "Mounish Savier", "text": "Your voice is so soothing too! Amazing video, i've always had a bit of a block when it comes to these graph algorithms but your approach/explanations finally helped me grasp them!!", "likes": 0}}, {"topLevelComment": {"author": "Ryan Le", "text": "know him from DP course. So amazing. Thank you Alvin", "likes": 0}}, {"topLevelComment": {"author": "simsim", "text": "53:44 how to do this in Python?", "likes": 0}, "replies": [{"author": "simsim", "text": "@Alvin the Programmer Thanks and i would like to tell that you are a great teacher. I have always feared using non linear ds like graph but you made it so easy to learn! Never in my life have i written a code by myself just by watching a video. So thanks for the video!", "likes": 1}, {"author": "Alvin the Programmer", "text": "I have created Python video walkthroughs for all of these same problems if you visit the Structy website. Check out the link in the video description. Once you are on the platform, you can set the language to Python in the top left corner. Hope that helps.", "likes": 0}]}, {"topLevelComment": {"author": "a2406", "text": "I know it's a stupid question, but you have to start from somewhere. At 34:06 it says n = # nodes, and n^2 = # edges. However, in the \"worst case\" illustration we clearly see 3 nodes. 3^2 = 9, but as the picture shows, the maximum amount of edges can be only 6. What's going on here?", "likes": 1}, "replies": [{"author": "a2406", "text": "@Alvin the Programmer It sure does! Thanks a lot for your answer!", "likes": 0}, {"author": "Alvin the Programmer", "text": "No such thing as a stupid question! Great question. The 3 edges that are missing are the trivial edges that leave and enter from the same node, i.e. a node that points to itself. Although uncommon, it is possible to have self referential edges like that. If we disallow self referential edges, then the worst case edges is n * (n - 1). We minus 1, because a node cannot point to itself. However, even with this constraint this is still described as O(n^2). Following the simplification rules: O(n * (n - 1)) = O(n^2 - n) = O(n^2).\n\nHope that clarifies! -AZ", "likes": 4}]}, {"topLevelComment": {"author": "Ming Lee", "text": "Interesting and useful", "likes": 0}}, {"topLevelComment": {"author": "Chris Korbel", "text": "This guy is phenomenal. His course on dynamic programming was exceptionally well done as well.", "likes": 383}, "replies": [{"author": "_oskr", "text": "@Mohamed Siddic Literally the comment above you", "likes": 0}, {"author": "Mohamed Siddic", "text": "Please share the dynamic programming link", "likes": 0}, {"author": "_oskr", "text": "@Elad 8 months too late, but here you go https://www.youtube.com/watch?v=oBt53YbR9Kk :P", "likes": 0}, {"author": "Chris Korbel", "text": "@Shubham Patrick https://youtu.be/oBt53YbR9Kk", "likes": 0}, {"author": "Chris Korbel", "text": "@George G https://youtu.be/oBt53YbR9Kk", "likes": 0}]}, {"topLevelComment": {"author": "Amadou Djoulde Barry", "text": "the course is amazing thank you", "likes": 1}}, {"topLevelComment": {"author": "Ahbar Ahad", "text": "Thank you Alvin, loved the DP course and this one as well", "likes": 2}}, {"topLevelComment": {"author": "Prashant Nigam", "text": "This was awesome. Can we please have next video on Union Find, Fenwick Trees, etc?", "likes": 0}}, {"topLevelComment": {"author": "shaad Ishtiaque", "text": "Wow... impressive tutorial.", "likes": 2}}, {"topLevelComment": {"author": "shanguang", "text": "My two years of fear just gone in two hours. Thank you sir.", "likes": 1}}, {"topLevelComment": {"author": "Varun Shridhar", "text": "The course on DP was a winner. Course on Graph algo is another winner. Hope to learn a lot more from you.", "likes": 98}, "replies": [{"author": "jooarago", "text": "@Travis Quigg \n\nin prolog:\n\nwinner(alvin).\nwinner(X) :- appreciates(X,Y), winner(Y).\n\nthat's it!", "likes": 0}, {"author": "Travis Quigg", "text": "@Tetrax you are a winner for appreciating a winner who also appreciated a winner who also appreciated a winner.", "likes": 0}, {"author": "Varun Shrivastava", "text": "if no_of_comments >= 6:\n              return \"Every One's a winnner!\"", "likes": 2}, {"author": "Tetrax", "text": "@LDAR let\u2019s assume we\u2019re on an alternate universe where leetcode doesn\u2019t have a time limit", "likes": 2}, {"author": "LDAR", "text": "@Tetrax this recursive call stack gotta stop somewhere XD", "likes": 3}]}, {"topLevelComment": {"author": "shayak ghosh", "text": "Can someone provide the c++ codes?", "likes": 1}}, {"topLevelComment": {"author": "shayak ghosh", "text": "Great explanation, thanks a lot. You are the reason i learnt a great deal about dynamic programming.", "likes": 0}}, {"topLevelComment": {"author": "Ignacio Rubio", "text": "Congratulations on this course, really well explained by Alvin.", "likes": 4}}, {"topLevelComment": {"author": "Jan Joska", "text": "Thank you. Drawing all that graphics had to take a lot of time.", "likes": 1}}, {"topLevelComment": {"author": "Prashant Nigam", "text": "More practice problems on LeetCode: \n* https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/\n* https://leetcode.com/problems/number-of-islands/\n* https://leetcode.com/problems/number-of-provinces/\n* https://leetcode.com/problems/max-area-of-island/", "likes": 2}, "replies": [{"author": "Amarnath Prasad", "text": "Thanks!", "likes": 0}]}, {"topLevelComment": {"author": "Vinod Kumar", "text": "You're doing an amazing job Alvin\ud83d\udc4dI'm always on lookout for your contents. Thank you!", "likes": 3}}, {"topLevelComment": {"author": "Rohit", "text": "Can't thank you enough guys :)", "likes": 1}}, {"topLevelComment": {"author": "Punith Ujwal Nayak", "text": "Thanks Alwin for this great tutorial. I had been trying to understand and get an answer to a similar set of problems for a very long time. You made my day, ...probably my life!", "likes": 6}}, {"topLevelComment": {"author": "Hao Shan", "text": "Your content is really helpful, respect!!", "likes": 1}}, {"topLevelComment": {"author": "Kai Tuo", "text": "Hey I know this guy from video in which he built a mern stack in 30 minutes!", "likes": 0}}, {"topLevelComment": {"author": "Sam", "text": "Python please", "likes": 0}, "replies": [{"author": "Alvin the Programmer", "text": "Python video walkthroughs for all of these same problems are available on structy! You can find a link to the platform in the video description. Hope you find them useful.", "likes": 1}]}, {"topLevelComment": {"author": "Tr\u00e2n Nguy\u1ec5n", "text": "I love this course", "likes": 0}}, {"topLevelComment": {"author": "Tr\u00e2n Nguy\u1ec5n", "text": "I love the courses", "likes": 0}}, {"topLevelComment": {"author": "Tr\u00e2n Nguy\u1ec5n", "text": "Thanks a bunch", "likes": 0}}, {"topLevelComment": {"author": "Tr\u00e2n Nguy\u1ec5n", "text": "Very very thank you", "likes": 0}}, {"topLevelComment": {"author": "Tr\u00e2n Nguy\u1ec5n", "text": "Thank you so much", "likes": 0}}, {"topLevelComment": {"author": "Rajan Sippy", "text": "Thanks", "likes": 2}}, {"topLevelComment": {"author": "Bhargav Pandya", "text": "I had no idea about graphs. Just decided to try the video out either way. I am quite surprised at how well this awesome person explains this concept to me! \n\nMake sure you understand a programming language pretty well and know some basics of BigO before watching this one. \n\nMind blowing explanation though!", "likes": 0}}, {"topLevelComment": {"author": "Gianni Zamora", "text": "FCC uploads right when we think of something to study and somehow it's that topic.", "likes": 0}}, {"topLevelComment": {"author": "Prashant Nigam", "text": "OMG this guy is back!!! \ud83d\ude0d", "likes": 1}}, {"topLevelComment": {"author": "Drone256", "text": "Thank you!  I learned this many years ago but watched just because your explanation is so elegant and relaxing. Lol.", "likes": 1}, "replies": [{"author": "Alvin the Programmer", "text": ":)", "likes": 0}]}, {"topLevelComment": {"author": "Subash Raj", "text": "Awesome teaching.. Thanks.", "likes": 0}}, {"topLevelComment": {"author": "Nilay Aslan", "text": "A very nice share. php turkey on a channel that I will recommend to you.", "likes": 0}}, {"topLevelComment": {"author": "Tic tok trending ", "text": "This guy is the best ....", "likes": 0}}, {"topLevelComment": {"author": "Made on Earth by humans \u4eba\u985e", "text": "hey i love ur t-shirt where i can buy officially rather than donate , i want to buy merchandise from freecode", "likes": 0}, "replies": [{"author": "freeCodeCamp.org", "text": "You can get shirts here: https://freecodecamp.creator-spring.com/", "likes": 0}]}, {"topLevelComment": {"author": "Utsav Arora", "text": "This is very good \nPlease can you bring one for the tree data structure also", "likes": 0}}, {"topLevelComment": {"author": "aditya", "text": "https://youtube.com/channel/UC-L61Y_YRMZrFnXvetHO_Lg", "likes": 0}}, {"topLevelComment": {"author": "Sashi Kant Shaw", "text": "was expecting at-least 1 mid to hard problem to be solved. All were easy ones. :(", "likes": 0}}, {"topLevelComment": {"author": "kondor1554", "text": "# of edges in a directed graph is n(n-1), not n^2", "likes": 1}, "replies": [{"author": "Soumik Sarkhel", "text": "@Siddhartha Gogoi yeah. Here meaning order of n\u00b2. Which is true for n(n-1)", "likes": 0}, {"author": "Siddhartha Gogoi", "text": "@Soumik Sarkhel Big Oh is for time complexity..", "likes": 0}, {"author": "Soumik Sarkhel", "text": "That's O(n\u00b2) still", "likes": 0}]}, {"topLevelComment": {"author": "pravat Yadav", "text": "Do more technical interview questions.... Sadly the project are only looked by interviewers after one passes coding challenge, in my country.. So unless you have made a project, framework that is likely to make million dollars, tech companies are not interested to hire you", "likes": 0}}, {"topLevelComment": {"author": "Marc", "text": "If you get stuck, always throw a hash map at the problem.", "likes": 0}}, {"topLevelComment": {"author": "Drew", "text": "are these questions asked in front end interviews???", "likes": 1}}, {"topLevelComment": {"author": "Q Ultimas", "text": "Thank you, this helps in brushing up on basic graph stuff :)", "likes": 2}}, {"topLevelComment": {"author": "Yogendra Tala", "text": "Thanks a lot", "likes": 0}}, {"topLevelComment": {"author": "Davit Mamrikishvili", "text": "49:16 Wouldn't the space complexity be O(n^2), as we are creating an adjacency list?", "likes": 1}, "replies": [{"author": "entcune", "text": "@Davit Mamrikishvili ya sorry i just completed it and was going through comment section and didn't see your comment was 1 month old \ud83d\ude05", "likes": 1}, {"author": "entcune", "text": "@Davit Mamrikishvili by complete you mean every node is connected to every other node in graph correct! In that case also the time complexity will be equal to total no of edges.", "likes": 1}, {"author": "Davit Mamrikishvili", "text": "I watched this a while ago I might be wrong", "likes": 1}, {"author": "Davit Mamrikishvili", "text": "@entcune The graph could be complete.", "likes": 1}, {"author": "entcune", "text": "You can create adjacency list by just one pass through given edges list. So, that's just e time complexity.", "likes": 0}]}, {"topLevelComment": {"author": "venkatesh kagalavadi", "text": "Sooper excited for this!! Thanks you! Your DP course is excellent!", "likes": 0}}, {"topLevelComment": {"author": "Daniel Fletcher", "text": "Thank you so much!!!!!!", "likes": 0}}, {"topLevelComment": {"author": "Kailash Ram", "text": "someone tell how I can pull myself out of online course purgatory!", "likes": 0}}, {"topLevelComment": {"author": "Robot Programmer", "text": "do whole dsa and algorithms in javascript", "likes": 1}}, {"topLevelComment": {"author": "Pete Davidson", "text": "hey programmers. congrats Alvin & shoutout to all the a/A grads too", "likes": 3}, "replies": [{"author": "Christian Cozma", "text": "@angelo oyardo It's App Academy, a coding bootcamp. Alvin was an instructor at App Academy a while back.", "likes": 0}, {"author": "Christian Cozma", "text": "a/A Represent!", "likes": 0}, {"author": "angelo oyardo", "text": "sorry, what's a/A?", "likes": 0}]}, {"topLevelComment": {"author": "RohitBR K", "text": "We need more problems on trees", "likes": 1}}, {"topLevelComment": {"author": "M L", "text": "I know him from the DP tutorial. This guy is amazing.", "likes": 75}, "replies": [{"author": "Ujjawal", "text": "Me also\ud83d\ude02", "likes": 0}, {"author": "Rakesh Katti", "text": "https://youtu.be/oBt53YbR9Kk", "likes": 1}, {"author": "Bhoomtawath Plinsut", "text": "Here's the link https://youtu . be/oBt53YbR9Kk", "likes": 0}, {"author": "Shashank Tiwari", "text": "Link?", "likes": 0}]}, {"topLevelComment": {"author": "Day Dream", "text": "This is great \u2764\ufe0f", "likes": 0}}, {"topLevelComment": {"author": "Oriol Cantarell i Sala", "text": "perfect!", "likes": 0}}, {"topLevelComment": {"author": "iDevBrandon", "text": "Yes! its explained in JAVASCRIPT!! THANK YOU SO MUCH", "likes": 3}}, {"topLevelComment": {"author": "Mohammed Zaid", "text": "Please upload a latest complete java course", "likes": 0}}, {"topLevelComment": {"author": "Ankit Dubey", "text": "Unbelievable sir  thanku so much\ud83d\ude0d", "likes": 0}}, {"topLevelComment": {"author": "RohitBR K", "text": "Lol I searched a lot about graph algorithms...but I hope this will solve my problems", "likes": 0}}, {"topLevelComment": {"author": "Franklin Ghosh", "text": "Wow!, Your DP course was phenomenal, now you came up with Graph theory too, Thank you", "likes": 85}, "replies": [{"author": "Alvin the Programmer", "text": "@Vinayak Tyagi Likely trees or linked lists next. You can check out my platform, Structy (link in the video description), if you want to check it out early before it premiers on free code camp.", "likes": 4}, {"author": "Mykola Zakharchuk", "text": "@Alvin the Programmer this is really true! you are the best!", "likes": 0}, {"author": "Vinayak Tyagi", "text": "@Alvin the Programmer  what next ?", "likes": 0}, {"author": "Alvin the Programmer", "text": "Glad to hear you found value in my content! More coming soon.", "likes": 10}]}, {"topLevelComment": {"author": "ManaphyGames", "text": "First", "likes": 0}}, {"topLevelComment": {"author": "Night Code", "text": "Leap Year Program | HTML , CSS & JavaScript\r\n\r\nhttps://youtu.be/DVzeO95HjkI", "likes": 0}}, {"topLevelComment": {"author": "Night Code", "text": "Leap Year Program | HTML , CSS & JavaScript\r\n\r\nhttps://youtu.be/DVzeO95HjkI", "likes": 0}}, {"topLevelComment": {"author": "Night Code", "text": "Leap Year Program | HTML , CSS & JavaScript\r\n\r\nhttps://youtu.be/DVzeO95HjkI", "likes": 0}}, {"topLevelComment": {"author": "Night Code", "text": "Leap Year Program | HTML , CSS & JavaScript\r\n\r\nhttps://youtu.be/DVzeO95HjkI", "likes": 0}}, {"topLevelComment": {"author": "rishabh yadav", "text": "Was waiting for you sunshine", "likes": 0}}, {"topLevelComment": {"author": "Max Knley", "text": "wow i love this dude", "likes": 1}}, {"topLevelComment": {"author": "Utkarsh Rastogi", "text": "Was looking for something like this and can't beleive you just uploaded it!", "likes": 52}, "replies": [{"author": "Karam Kassem", "text": "Me too", "likes": 2}]}, {"topLevelComment": {"author": "Vpundir 30", "text": "But I am a 12 year old pro programmer \ud83d\udc68\u200d\ud83d\udcbb but don\u2019t like the first like and other things", "likes": 2}}, {"topLevelComment": {"author": "Aditya Singh", "text": "Tech interviews are not this easy. Lets do a course on DP on trees and graphs.", "likes": 0}}, {"topLevelComment": {"author": "Webcodingo [Programming Tips]", "text": "Awesome work! You inspired me to start my coding channel!", "likes": 8}}, {"topLevelComment": {"author": "Vpundir 30", "text": "A 4 views in 10 seconds can be only of the people who says first like or first Comment", "likes": 1}}, {"topLevelComment": {"author": "Anna's YT Channel", "text": "Definitely was looking for this! Thanks! \u2764\ufe0f", "likes": 3}}, {"topLevelComment": {"author": "Anonymous", "text": "First \u2764\ufe0f", "likes": 0}}, {"topLevelComment": {"author": "No Copyright Gameplay Stock Videos", "text": "\ud83d\udd25\ud83d\udd25\ud83d\udd25\ud83d\udd25\ud83d\udd25\ud83d\udd25\ud83d\udd25\ud83d\udd25", "likes": 3}}, {"topLevelComment": {"author": "Sanjay K", "text": "Wow! Was waiting for this", "likes": 3}}, {"topLevelComment": {"author": "Vibhash ranjan ray", "text": "Second", "likes": 1}}, {"topLevelComment": {"author": "Amrit Singh", "text": "First", "likes": 1}}]}