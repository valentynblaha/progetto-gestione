{"video": {"id": "7XmS8McW_1U", "title": "Trie Data Structure - Beau teaches JavaScript", "description": "The trie data structure (sometimes called a prefix tree) is a special type of tree used to store associative data structures. Learn more about tries and how to implement them in JavaScript.\n\n\ud83d\udcbb Code: https://codepen.io/beaucarnes/pen/mmBNBd?editors=0011\n\n\ud83d\udd17 More info: https://medium.com/algorithms/trie-prefix-tree-algorithm-ee7ab3fe3413\n\n\ud83d\udc26 Beau Carnes on Twitter: https://twitter.com/carnesbeau\n\n\u2b50JavaScript Tutorials Playlists\u2b50\n\u25b6JavaScript Basics: https://www.youtube.com/playlist?list=PLWKjhJtqVAbk2qRZtWSzCIN38JC_NdhW5\n\u25b6Data Structures and Algorithms: https://www.youtube.com/playlist?list=PLWKjhJtqVAbkso-IbgiiP48n-O-JQA9PJ\n\u25b6Design Patterns: https://www.youtube.com/playlist?list=PLWKjhJtqVAbnZtkAI3BqcYxKnfWn_C704\n\u25b6ES6: https://www.youtube.com/playlist?list=PLWKjhJtqVAbljtmmeS0c-CEl2LdE-eR_F\n\u25b6Clean Code: https://www.youtube.com/playlist?list=PLWKjhJtqVAbkK24EaPurzMq0-kw5U9pJh\n\n-\nWe're busy people who learn to code, then practice by building projects for nonprofits. Learn Full-stack JavaScript, build a portfolio, and get great references with our open source community.\n\nJoin our community at https://freecodecamp.com\nRead great tech articles at https://medium.freecodecamp.com", "duration": "PT12M32S", "likes": "418", "views": "31144"}, "comments": [{"topLevelComment": {"author": "Kelly X", "text": "Hi, thanks for the great course. Just one question, at 7:45, \"which would be the O node\", shouldn't that be the d node?", "likes": 0}}, {"topLevelComment": {"author": "William Ikenna-Nwosu", "text": "Nice trie Beau", "likes": 1}}, {"topLevelComment": {"author": "Larisa Bobrovnikova", "text": "Thanks so so so much! You are the best <3", "likes": 0}}, {"topLevelComment": {"author": "Felipe", "text": "if I run isWord(\"all\"), shouldn't it return true?", "likes": 0}}, {"topLevelComment": {"author": "amitava mozumder", "text": "why add a getter and setter for the \"end\" property, but use the \"keys\" property directly?", "likes": 0}}, {"topLevelComment": {"author": "The'1'minreviewer", "text": "thanks  man!", "likes": 0}}, {"topLevelComment": {"author": "Doug", "text": "Thanks very helpful! Isn\u2019t substring a O(n) operation though? That means search operations are increased from O(n) to O(n^2), since you create a new string for each iteration", "likes": 0}, "replies": [{"author": "Zain E. Yousaf-Fuentes", "text": "You can get by in c doing something pointer + index for substr though.", "likes": 0}, {"author": "Zain E. Yousaf-Fuentes", "text": "Exactly. Very poor design. Literally can be reduced down to n with a counter variable from 0 to n - 1", "likes": 0}]}, {"topLevelComment": {"author": "shen sean", "text": "use the convention name would be clearer. good content tho, thanks", "likes": 0}}, {"topLevelComment": {"author": "Justin Meskan", "text": "What about \"Do\" you never printed it out or showed us how you know when you've come to the end of a word that could be a part of a longer word. Do and then Done Done prints because it is the end of the branch and has no children but Do, has children and therefor does not get printed out.", "likes": 2}, "replies": [{"author": "Justin Meskan", "text": "print() {\n\t\tconst words = []\n\t\tfunction search(node, string) {\n\t\t\tconsole.log(\"isEnd\", node.isEnd())\n\t\t\t\n\t\t\tif(node.keys.size != 0) {\n\t\t\t\tif(node.isEnd()) {                            // ADDED LINE\n\t\t\t\t\twords.push(string)                 // ADDED LINE\n\t\t\t\t}                                                         // ADDED LINE\n\t\t\t\tfor(let letter of node.keys.keys()) {\n\t\t\t\t\tsearch(node.keys.get(letter), string.concat(letter))\n\t\t\t\t}\n\t\t\t} \n\t\t\telse {\n\t\t\t\tif(node.isEnd()) {\n\t\t\t\t\twords.push(string)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsearch(this.root, '')\n\n\t\treturn words\n\t\t\n\t}", "likes": 1}]}, {"topLevelComment": {"author": "Shini1984", "text": "I'd like to offer a suggestion: when adding a word, you use substring. There are two problem with this approach. 1. Substring iterates over a string in O(n) time. 2. Substring creates a copy of the string (because it is immutable). So it needs O(n) time for each iteration and O(n - 1) = O(n) space for each iteration, which makes it O(n^2) time and space complexity when adding.\nI suggest using an array (word.split(\"\")) and passing around both the array itself and current index when adding the word. Benefits: we don't do substring, we simply iterate index by one. Both of these are done in O(1) time and don't use any extra space.\n\nOther than that I'd use while loop to iterate over the the nodes instead of using recursion. This allows us not to worry about recursion stack overflowing (which may or may not become an issue in the long run).\n\nI realize this is a 3 year old video, I'm just hoping someone will find this useful, as I found this video quite useful for understanding Tries and how to implement them in JS.\n\nThanks for the explanation! It may not be perfect, but it is quite useful.", "likes": 4}}, {"topLevelComment": {"author": "aylictal", "text": "just fyi in your isWord return you're returning a boolean ternary which is an antipattern.\n\nyou can simply call return node.keys.has(word) && node.keys.get(word).isEnd()", "likes": 1}, "replies": [{"author": "aylictal", "text": "@Doug Even still there are others that can't comprehend that code like the following is an antipattern:\n\nreturn true ? true ? true ? true : false : false ? true : false : false ? false ? true : false : true ? true : false;", "likes": 0}, {"author": "Doug", "text": "It is not an antipattern, it is just a code style preference. And both of those things are not the point of the video", "likes": 0}, {"author": "aylictal", "text": "@Aamir Afridi i humbly disagree and was taught differently, and perform in the working world differently.", "likes": 0}, {"author": "Aamir Afridi", "text": "@aylictal it's different. In his code, he is using this syntax \"return condition && condition ? true : false\" He could just \"return condition && condition\" but for this video you want to focus on the problem and in this case you have to calculate what \"condition && condition\" will return. Also if you \"return condition && 123\" you are returning  123 if the condition is true but with with \"return condition && 123 ? true : false\" you are returning a boolean. So to return a boolean you can \"return condition && Boolean(123)\" which is fine and works too. But my point is that its easy to read for the sake of this example to specifically return a boolean (true or false)", "likes": 0}, {"author": "aylictal", "text": "would be equivalent to writing an if statement \n\nif (true ? true : false) {} \nvs\nif (true) {}\n\nwhich is easier to read?", "likes": 0}]}, {"topLevelComment": {"author": "Vijaya Nistala", "text": "I am unable to write the remove method for this particular code...can anyone please help me with it?", "likes": 0}}, {"topLevelComment": {"author": "Isosceles Kramer", "text": "const Node, const Trie", "likes": 1}}, {"topLevelComment": {"author": "sha p", "text": "Thanks a lot sir, really wounderful , i have a DS question for you , please help me ......Have one DS question, need anser.\nQ : we have a city , in which we have locations, each location has few restaurents.\nOne ( ex: KFC) restaurent might be in multiple locations( like HiTechcity, Nampally etc).\n\nTo Given restaurent get all its locations, given location display all restaruents in that location.\nWhat Data Structure use this problem?", "likes": 0}}, {"topLevelComment": {"author": "MM 754", "text": "Cool video. You can make the \"add\" function a bit simpler by removing the \"else\" and the return statement above it. Because both return statements around \"else\" are doing the same thing.", "likes": 2}}, {"topLevelComment": {"author": "Alexander Taran", "text": "\"search\" is  a bit misleading name for the function that simply walks through the tree.", "likes": 6}}, {"topLevelComment": {"author": "Joseph Morales", "text": "thanks man. I have an interview with microsoft next week. Really fucking hope the trie isnt in the interview hahaha.", "likes": 8}, "replies": [{"author": "Sibasish Sahu", "text": "Good Luck \ud83d\udc4d", "likes": 0}, {"author": "Funky Buddha", "text": "Trie it is then!!", "likes": 0}]}, {"topLevelComment": {"author": "Callum Hays", "text": "What is the the practical application of this over a hashmap lookup?", "likes": 3}, "replies": [{"author": "Bryan Timah", "text": "@It's Aaron Sure \ud83d\ude02, I just had to try", "likes": 0}, {"author": "It's Aaron", "text": "@Bryan Timah you were 5 years late \ud83d\ude02", "likes": 0}, {"author": "Bryan Timah", "text": "I think it's good at implementing an auto complete function in a browser", "likes": 0}, {"author": "Callum Hays", "text": "Thank you so much!", "likes": 1}]}, {"topLevelComment": {"author": "\u25cb", "text": "In `isWord`, you could also have used `node` as the second parameter, just like in `add`, right?\nVery good explanation tho, thank you!", "likes": 2}}, {"topLevelComment": {"author": "MagicMoshroom", "text": "Great explanation and very useful data structure", "likes": 3}}]}