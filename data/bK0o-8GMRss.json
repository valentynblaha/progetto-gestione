{"video": {"id": "bK0o-8GMRss", "title": "Condensing Sentences - The Daily Programmer #319", "description": "Here is the link to the Daily Programmer sub-reddit where this problem was original found: https://www.reddit.com/r/dailyprogrammer/comments/6grwny/20170612_challenge_319_easy_condensing_sentences/\n\nFollow me on twitter: https://twitter.com/CodyLSeibert\n\nHelp us improve our videos by taking this short survey here:\nhttps://goo.gl/forms/rustp398xzDYRZoI3\n\nLearn to code for free and get a developer job: https://www.freecodecamp.com\n\nRead hundreds of articles on programming: https://medium.freecodecamp.com", "duration": "PT11M", "likes": "290", "views": "9920"}, "comments": [{"topLevelComment": {"author": "Ang W", "text": "really nice explanation ~ thanks!", "likes": 0}}, {"topLevelComment": {"author": "Gurmeet Singh", "text": "I am getting confused in my python solution as i am unable to remove next element fro my list of words. pleas help:\ndef condense(left,right):\n    for i in range(len(left)):\n        sub=left[i:]\n        if right.startswith(sub):\n            return left +right.replace(sub,'')\n    return None\n\n\ndef con_sen(sent):\n    words=sent.split(' ')\n    for i in range(len(words)-1):\n        condensed=condense(words[i],words[i+1])\n        if condensed:\n            words[i]=condensed\n            words[i+1]\n            i-=1\n            \n            \n    return ' '.join(words)\nprint(con_sen('no one ever runs so often'))", "likes": 0}, "replies": [{"author": "Gurmeet Singh", "text": "nice thought, but this is how i solved the i=i-1 problem, the pop statement itself reduces the length of the array\ndef con_sen(sent):\n    \n    words=sent.split(' ')\n    l=len(words)\n    for i in range(l-1):\n        condensed=condense(words[i],words[i+1])\n        if condensed:\n            words[i]=condensed\n            words.pop(i+1)\n        if i==len(words)-1:\n            break               \n    return ' '.join(words)", "likes": 0}, {"author": "freeCodeCamp.org", "text": "I don't know python that well, but I think you can just use:\n\ndel words[i+1]", "likes": 0}]}, {"topLevelComment": {"author": "mohammad omer", "text": "Can you tell me what editor do you use in this video", "likes": 0}, "replies": [{"author": "mohammad omer", "text": "freeCodeCamp so how u run it like that is that plug in ?", "likes": 0}, {"author": "freeCodeCamp.org", "text": "Atom.", "likes": 1}]}, {"topLevelComment": {"author": "Yuval Blass", "text": "Which keyboard do you have? You type so fast... :)", "likes": 1}, "replies": [{"author": "freeCodeCamp.org", "text": "I'm just using my Mac Book Pro keyboard.", "likes": 1}]}, {"topLevelComment": {"author": "Sladyn Nunes", "text": "How do you get that command line on atom.I just downloaded atom so ill be glad if anyone could help me", "likes": 3}}, {"topLevelComment": {"author": "Jarrett Klink", "text": "what editor is that? if its atom, what package are you using to run it in editor?", "likes": 2}, "replies": [{"author": "Todd Jones", "text": "https://atom.io/packages/terminal-panel this looks like the plugin", "likes": 0}]}, {"topLevelComment": {"author": "J.D. Sandifer", "text": "I'm not sure it was clear what should happen with an edge case like \"leg ego lego\", but it seems like it would not be handled correctly if the correct answer is \"lego lego\". (Ego does not combine with lego...but the combination of leg and ego into lego does combine with lego.) Could you address that?", "likes": 3}, "replies": [{"author": "sajid ali mudassar", "text": "The solution with regular expression solves this edge case.\nconsole.log(\"leg ego lego\".replace(/(\\w+)\\s+\\1/g, \"$1\"))\nwill print\n\"lego lego\"", "likes": 0}, {"author": "Gray Smith", "text": "noob here, but i think what JD is saying is that, the way the question is asked it doesn't assume you would connect the first words before you check to see whether the rest of the the words connect. So the correct answer for \"leg ego lego\" would be \"lego lego\" since \"leg\" and \"ego\" connect, but by itself \"ego\" does not connect to \"lego\". However, with the videos way of solving the problem, \"leg\" and \"ego\" would be condensed to \"lego\" before checking to see if that connects with \"lego\" which it does leaving you only with \"lego\" as the answer, which would be wrong. Ooookay, haha i hope that was clear.", "likes": 0}, {"author": "freeCodeCamp.org", "text": "The problem description / example input for the problem are unfortunately  not too verbose, but I'd assume if you encounter a sentence such as \"leg ego lego\", this whole sentence would be combined into \"lego\" because we'd condense \"leg\" with \"ego\" making \"lego\", then we'd condense \"lego\" with \"lego\", thus making \"lego\".", "likes": 3}, {"author": "Mohammad Al-Abbasi", "text": "what do you mean by edge case?", "likes": 0}]}, {"topLevelComment": {"author": "akinhwan. com", "text": "awesome!", "likes": 0}}, {"topLevelComment": {"author": "vigilantezack", "text": "I did mine with reduce:\n\n{\n    function converter(str) {\n        let strarr = str.split(\" \");\n        let ans = strarr.reduce(function(l, r) {\n            for (let i = 0; i < l.length; i++) {\n                let leftSubstring = l.substring(i);\n                if (r.startsWith(leftSubstring)) {\n                    return l + r.replace(leftSubstring, '');\n                }\n            }\n            return l + \" \" + r;\n        });\n        return ans;\n    }\n\n    console.log(converter(\"no one ever runs so often\"));\n    console.log(converter(\"yellow low dog\"));\n    console.log(converter(\"the black kettle is hot\"));\n    console.log(converter(\"hello world\"));\n}", "likes": 3}}, {"topLevelComment": {"author": "Jani \u0160umak", "text": "A good exercise to practice reduce \n\nHere is my jsbin https://jsbin.com/xoqajidofo/edit?js,console", "likes": 1}}, {"topLevelComment": {"author": "Jordan Burnett", "text": "couldn't we have just used regular expressions to solve this ?", "likes": 1}, "replies": [{"author": "Jordan Burnett", "text": "i think you were right about that. This was very helpful", "likes": 1}, {"author": "freeCodeCamp.org", "text": "We sure can! That was mentioned near the end as possible solution, but I felt make a video with one line of code wouldn't be that interesting.", "likes": 4}]}, {"topLevelComment": {"author": "KozmicLuis", "text": "You could solve with regex:\n\nconst condense = (sentence) => return sentence.replace(/(\\w+)\\s+\\1/g, \"$1\")\n\nEDIT: Holy shit I just checked the Reddit link, I was about to go like \"Move along bois, I got this with my regex\" and the most voted solution is exactly the same, except he named things differently (compress and str instead of condense and sentence). I guess we're not alone in this world.\n\nThe idea here is that, the regular expression first captures 1 or more alphanumeric characters ((\\w+)) and stores it as \"capture group #1, then it matches 1 or more whitespace characters, then it matches the capture group #1 (\\1) and the /g flag means that we want to replace all instances of this pattern (1 or more alphanumeric characters followed by any number of spaces followed by the same 1 or more alphanumeric characters of the ending of the previous word); now, the 2nd argument says that all of those instances ought to be replaced by a string that only contains the first capturing group. So for example:\n\n\"live verses\", the regexp will capture \"ve\" in \"live\" and then it will match the only space between them, then it will check to see if all of the previous things are followed by \"ve\", if that's true, it means that there's a replaceable match and then it replaces \"ve ve\" (the final match) with \"$1\" which the replace method will turn into \"ve\".", "likes": 11}, "replies": [{"author": "Jeff Lin", "text": "Uncaught SyntaxError: Unexpected token return.Don't need \"return\" here.", "likes": 0}, {"author": "Rafa\u0142 Sobczyk", "text": "Unless you're compiling your regex inside three nested loops with thousands of iteration, you shouldn't worry about performance. But since regex can easily become write-only you shouldn't use them everywhere.", "likes": 0}, {"author": "Mohammad Al-Abbasi", "text": "So in summary, the first argument finds the pattern (a character followed by a whitespace) and the second argument replaces the next match?\n\nAppreciate the explanation, you just earned a subscriber!", "likes": 0}]}, {"topLevelComment": {"author": "Nerve Clasp", "text": "I got this one. Pretty bad code and a quick one, but slightly different, so I figured why not share it:) (sorry))\nhttps://gist.github.com/NerveClasp/3e24dc26f627439b42bc6e3579cfe40c", "likes": 3}, "replies": [{"author": "freeCodeCamp.org", "text": "I do like your solution using reduce; I didn't think about that!", "likes": 1}, {"author": "Nerve Clasp", "text": "yours is definnitely better and faster, as mine will have to check full stitched \"prev\" string when given a long sentense. Thank you for the video! More of the same please", "likes": 1}]}, {"topLevelComment": {"author": "C K", "text": "What syntax theme is that, seems like an edited one dark.", "likes": 0}, "replies": [{"author": "freeCodeCamp.org", "text": "It was the default theme for js file in the Atom editor.", "likes": 0}]}]}