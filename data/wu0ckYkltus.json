{"video": {"id": "wu0ckYkltus", "title": "Graphs: breadth-first search - Beau teaches JavaScript", "description": "Traversal algorithms are algorithms to traverse or visit nodes in a graph. In this video, I will be showing how to implement breadth-first search traversal algorithm in JavaScript.\n \nThe algorithm starts at one node, first visits all its neighbors that are one edge away, then goes on to visiting each of their neighbors. The point is to determine how close nodes are to a root node.\n\n\n\ud83d\udcbb Code: https://codepen.io/beaucarnes/pen/XgrXvw?editors=0012\n\n\ud83d\udc26 Beau Carnes on Twitter: https://twitter.com/carnesbeau\n\n\u2b50JavaScript Tutorials Playlists\u2b50\n\u25b6JavaScript Basics: https://www.youtube.com/playlist?list=PLWKjhJtqVAbk2qRZtWSzCIN38JC_NdhW5\n\u25b6Data Structures and Algorithms: https://www.youtube.com/playlist?list=PLWKjhJtqVAbkso-IbgiiP48n-O-JQA9PJ\n\u25b6Design Patterns: https://www.youtube.com/playlist?list=PLWKjhJtqVAbnZtkAI3BqcYxKnfWn_C704\n\u25b6ES6: https://www.youtube.com/playlist?list=PLWKjhJtqVAbljtmmeS0c-CEl2LdE-eR_F\n\u25b6Clean Code: https://www.youtube.com/playlist?list=PLWKjhJtqVAbkK24EaPurzMq0-kw5U9pJh\n\n-\nLearn to code for free and get a developer job: https://www.freecodecamp.com\n\nRead hundreds of articles on technology: https://medium.freecodecamp.com\n\nAnd subscribe for new programming videos every day: https://youtube.com/subscription_center?add_user=freecodecamp", "duration": "PT6M11S", "likes": "517", "views": "46439"}, "comments": [{"topLevelComment": {"author": "JorDANStew", "text": "What do you smell. U smell that", "likes": 0}}, {"topLevelComment": {"author": "Edet Mmekut", "text": "dame nice  explanation but to to computer science", "likes": 0}}, {"topLevelComment": {"author": "satya VALLURI", "text": "Cool", "likes": 0}}, {"topLevelComment": {"author": "Deepali Garg", "text": "Best code and best explanation I have found so far on breadth first search using Javascript. Thank You for making this excellent video.", "likes": 0}}, {"topLevelComment": {"author": "Mikah Feldman-Stein", "text": "Very fast, very poorly explained.", "likes": 0}}, {"topLevelComment": {"author": "Aleks Gavrilov", "text": "reviewed three times, and did not understand", "likes": 0}}, {"topLevelComment": {"author": "phuc nguyen phi", "text": "how can i draw a graph and animate some algorithms like dijikstra, prim... in html/css/js?", "likes": 0}}, {"topLevelComment": {"author": "sidework1", "text": "How is node 3 connected to itself?", "likes": 0}}, {"topLevelComment": {"author": "Of Noise/Altered Tastes", "text": "Thanks for explanation. The nested while and for loops, indexOfs, and neighborIdx array however add confusion. indexOf is O(n) so not sure why you wouldn't just use a loop over curConnected to locate 1's and enqueue/push the corresponding indexes and set the distances.\n\nfor (var j = 0; j < curConnected.length; j++) {\n     if (curConnected[j] === 1 && nodesLen[j] === Infinity) {\n          queue.push(j);\n          nodesLen[j] = nodesLen[current] + 1;\n     }\n}", "likes": 2}}, {"topLevelComment": {"author": "Ankit Pradhan", "text": "it would have been great if you have described the code line by line with example", "likes": 5}, "replies": [{"author": "apex1212", "text": "Yeah I must agree, this is more for intermediate  student learning, not exactly beginner friendly. But one way to truly understand this code is c&p it and go trough it with a debugger, then you can really see what is going on under the hud  \ud83d\udc4d", "likes": 0}]}, {"topLevelComment": {"author": "Shrivas Nayar", "text": "can someone please explain how does the code determine for root node 1, the distance of node 3 as 3?", "likes": 0}}, {"topLevelComment": {"author": "The happy person", "text": "with the distance in mind .. you're saying BFS is weighted where its an unweighted graph.", "likes": 0}}, {"topLevelComment": {"author": "Pradeep Vig", "text": "The variable names are so confusing. Good lecture otherwise.", "likes": 2}}, {"topLevelComment": {"author": "Gy\u00f6rgy M\u00e1rk", "text": "nice explanation. thank you so much!", "likes": 0}}, {"topLevelComment": {"author": "dnavas77", "text": "For Loop within the while loop explained:\n\n\nFor every neighbor \"j\" of node 1:\n      1. if the distance from 1 to neighbor \"j\" is infinity, assign distance to \"distance to current node + 1\"\n                (a) For example if current is node 2, its distance is 1 because it was assigned in the previous loop, thus the distance to 0 will be 1 + 1.\n\n      2. push neighbor \"j\" to queue.", "likes": 4}}, {"topLevelComment": {"author": "Jbdoster", "text": "I searched \"depth first algorithm javascript\" into YouTube and took a huge sigh of relief seeing \"Beau teaches JavaScript\"", "likes": 2}, "replies": [{"author": "ANJUM KHANDESHI", "text": "Thats nice but this is BFS", "likes": 0}]}, {"topLevelComment": {"author": "Pran B.", "text": "there is a flaw in this logic...it runs in an infinite loop..not maintaining the visited nodes", "likes": 0}, "replies": [{"author": "Raul Alfonso Cayo", "text": "No it doesn't, if is already visited the value won't be Infinity and nothing will to be added to the queue.", "likes": 0}]}, {"topLevelComment": {"author": "Mohsin IO", "text": "WOrst Explanation Ever just Read code lines nothing explain.\nplease dont make videos if you dont know how to explain dont just read.", "likes": 5}, "replies": [{"author": "Gal Margalit", "text": "it's quite good as a refresher but not for learning the basics", "likes": 3}]}, {"topLevelComment": {"author": "Farhan Ahmed", "text": "Thanks for this. nice explanation", "likes": 1}}, {"topLevelComment": {"author": "Durjoy Talukdar", "text": "4:15", "likes": 0}}, {"topLevelComment": {"author": "Tiki Pak", "text": "It's a bit confusing when you go into the for loops and neighbors...it would help if you had some graphical representation to refer to which cells you are referring to...", "likes": 5}}, {"topLevelComment": {"author": "Divyanshu Mittal", "text": "you are not maintaining a visited array, won't it run into an infinite loop? and keep pushing and popping the same node again and again? in this case: 1 -> 2 -> 1 -> 2....", "likes": 2}, "replies": [{"author": "israel meza", "text": "I think line 26 (if(nodeLen[nodeIdx[j]] == Infinity )) prevents from pushing 1 back, since its length has already been set and is no longer infinity", "likes": 1}]}, {"topLevelComment": {"author": "Mostafa Mohamed", "text": "at 4:15 you said it is connected to nodes 0 and 2 but it is connected only to 2, right?", "likes": 12}, "replies": [{"author": "Les IsMore", "text": "@Raymond Zheng Thanks. That was so confusing.", "likes": 0}, {"author": "Raymond Zheng", "text": "Correct Beau made the error. At node one (in this case the root node), it is just connected to node 2, and not node 0.", "likes": 1}, {"author": "JustShillingz", "text": "I thought I was the only one that noticed this. Thank you for the question. Lol. You are right though.", "likes": 1}]}, {"topLevelComment": {"author": "Ownage Juice", "text": "thanks for this.", "likes": 0}}]}